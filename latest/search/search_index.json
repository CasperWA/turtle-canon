{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Turtle Canon \u00b6 It's turtles all the way down A tool for canonizing Turtle ( .ttl ) ontology files. The domain standardized tool for editing and creating ontologies is Prot\u00e9g\u00e9 . The Turtle ( .ttl ) file format is a format based on XML and OWL, which is considered one of the most readable formats for OWL ontology files. However, Prot\u00e9g\u00e9 writes the order of ontology entities differently depending on the version, this tool mitigates this by running the file through a canonizing parser that ensures the classes are sorted and listed in the same way, always. The main use case for developing this tool is when developing ontologies utilizing versioning tools such as git , svn or similar, which are single character diff-sensitive. Install \u00b6 The tool is written for Python 3.9, so one needs at minimum Python 3.9 installed to run it at this stage. The plan is to make a stand-alone executable for each of the major OS'. Install via PyPI (stable version, recommended): python3.9 -m pip install turtle-canon Install via GitHub (development version): python3.9 -m pip install git+https://github.com/CasperWA/turtle-canon#egg = turtle-canon Usage \u00b6 To run the tool, simply run: turtle-canon path/to/my_ontology_file.ttl For more information about the tool and the options available, run turtle-canon --help . To check the version run turtle-canon --version . The currently latest stable version is 0.0.1 . License & copyright \u00b6 This tool is MIT Licensed and copyright \u00a9 2021 Casper Welzel Andersen ( GitHub , GitLab , website ) & SINTEF.","title":"Turtle Canon"},{"location":"#turtle-canon","text":"It's turtles all the way down A tool for canonizing Turtle ( .ttl ) ontology files. The domain standardized tool for editing and creating ontologies is Prot\u00e9g\u00e9 . The Turtle ( .ttl ) file format is a format based on XML and OWL, which is considered one of the most readable formats for OWL ontology files. However, Prot\u00e9g\u00e9 writes the order of ontology entities differently depending on the version, this tool mitigates this by running the file through a canonizing parser that ensures the classes are sorted and listed in the same way, always. The main use case for developing this tool is when developing ontologies utilizing versioning tools such as git , svn or similar, which are single character diff-sensitive.","title":"Turtle Canon"},{"location":"#install","text":"The tool is written for Python 3.9, so one needs at minimum Python 3.9 installed to run it at this stage. The plan is to make a stand-alone executable for each of the major OS'. Install via PyPI (stable version, recommended): python3.9 -m pip install turtle-canon Install via GitHub (development version): python3.9 -m pip install git+https://github.com/CasperWA/turtle-canon#egg = turtle-canon","title":"Install"},{"location":"#usage","text":"To run the tool, simply run: turtle-canon path/to/my_ontology_file.ttl For more information about the tool and the options available, run turtle-canon --help . To check the version run turtle-canon --version . The currently latest stable version is 0.0.1 .","title":"Usage"},{"location":"#license-copyright","text":"This tool is MIT Licensed and copyright \u00a9 2021 Casper Welzel Andersen ( GitHub , GitLab , website ) & SINTEF.","title":"License &amp; copyright"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2021 Casper Welzel Andersen & SINTEF Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"LICENSE"},{"location":"design/","text":"Design outline \u00b6 As outlined on the landing page, the goal of the Turtle Canon tool is to canonize (or standardize) the Turtle ontology files exported by, especially, Prot\u00e9g\u00e9 . To achieve this, RDFlib is utilized to load in the Turtle file as a rdflib.Graph object, retrieving all the triples, sorting them, creating an empty, new rdflib.Graph object, add the sorted list of triples, and then export the ontology as a Turtle file, overwriting the original Turtle file. In this process, precautions are taken to ensure the Turtle file is only overwritten if everything has gone as expected and an extensive validation of the input Turtle file is undertaken before even parsing it as a rdflib.Graph object. Same ontology - different generation tools \u00b6 For the use case of having the same ontology, but in a logically different state, e.g., when triples may be added upon reasoning an ontology, but it is still considered to be the same ontology, the canonization process falters. It falters in the sense that Turtle Canon considers the provided list of triples to be the ultimate source of truth for canonization. Turtle Canon will not try to reason or infer what set of triples have been added during a reasoning process, and which were the \"original\". It will instead merely retrieve the list of triples, sort them, and export them as a Turtle file, overwriting the source Turtle file. diff tool \u00b6 It is the intention to add a diff -like tool for these events, where the differing set of triples are listed when comparing two Turtle files. From there, adding functionality to interactively manipulate which triples should be created or removed should be somewhat straight-forward. The intention is to add exactly this, however, the exact design for this has not yet been determined. The initial point of this tool is to help users be aware that changes have occurred between two ontologies, what they are, and understand whether they are semantic or logical.","title":"Design outline"},{"location":"design/#design-outline","text":"As outlined on the landing page, the goal of the Turtle Canon tool is to canonize (or standardize) the Turtle ontology files exported by, especially, Prot\u00e9g\u00e9 . To achieve this, RDFlib is utilized to load in the Turtle file as a rdflib.Graph object, retrieving all the triples, sorting them, creating an empty, new rdflib.Graph object, add the sorted list of triples, and then export the ontology as a Turtle file, overwriting the original Turtle file. In this process, precautions are taken to ensure the Turtle file is only overwritten if everything has gone as expected and an extensive validation of the input Turtle file is undertaken before even parsing it as a rdflib.Graph object.","title":"Design outline"},{"location":"design/#same-ontology-different-generation-tools","text":"For the use case of having the same ontology, but in a logically different state, e.g., when triples may be added upon reasoning an ontology, but it is still considered to be the same ontology, the canonization process falters. It falters in the sense that Turtle Canon considers the provided list of triples to be the ultimate source of truth for canonization. Turtle Canon will not try to reason or infer what set of triples have been added during a reasoning process, and which were the \"original\". It will instead merely retrieve the list of triples, sort them, and export them as a Turtle file, overwriting the source Turtle file.","title":"Same ontology - different generation tools"},{"location":"design/#diff-tool","text":"It is the intention to add a diff -like tool for these events, where the differing set of triples are listed when comparing two Turtle files. From there, adding functionality to interactively manipulate which triples should be created or removed should be somewhat straight-forward. The intention is to add exactly this, however, the exact design for this has not yet been determined. The initial point of this tool is to help users be aware that changes have occurred between two ontologies, what they are, and understand whether they are semantic or logical.","title":"diff tool"},{"location":"api_reference/canon/","text":"canon \u00b6 The main turtle-canon module. canonize ( turtle_file ) \u00b6 The main function for running turtle-canon . Workflow: - Validate Turtle file. Check the file integrity, readability, writeability and content. - Parse and sort Turtle file's triples. Parse Turtle file using RDFlib. Retrieve triples, sort them, and generate a new RDFlib Graph from the sorted triples. - Export ontology as Turtle file. Overwriting loaded Turtle file, i.e., overall the canonization is done in-place. Parameters: Name Type Description Default turtle_file Union[Path, str] An absolute path or pathlib.Path object representing the Turtle file location. required Returns: Type Description Union[Path, None] If the file has been changed during the canonization, the Turtle file's Union[Path, None] location will be returned, otherwise None will be returned. Source code in turtle_canon/canon.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def canonize ( turtle_file : \"Union[Path, str]\" ) -> \"Union[Path, None]\" : \"\"\"The main function for running `turtle-canon`. Workflow: - **Validate** Turtle file. Check the file integrity, readability, writeability and content. - **Parse** and **sort** Turtle file's triples. Parse Turtle file using RDFlib. Retrieve triples, sort them, and generate a new RDFlib `Graph` from the sorted triples. - **Export** ontology as Turtle file. Overwriting loaded Turtle file, i.e., overall the canonization is done in-place. Parameters: turtle_file: An absolute path or `pathlib.Path` object representing the Turtle file location. Returns: If the file has been changed during the canonization, the Turtle file's location will be returned, otherwise `None` will be returned. \"\"\" valid_turtle_file = validate_turtle ( turtle_file ) sorted_ontology = sort_ontology ( valid_turtle_file ) changed_file = export_ontology ( sorted_ontology , valid_turtle_file ) return Path ( turtle_file ) if changed_file else None export_ontology ( ontology , filename ) \u00b6 Export an ontology as a Turtle file. Parameters: Name Type Description Default ontology Graph A loaded ontology. required filename Path The Turtle file's fully resolved path to export to. required Returns: Type Description bool Whether or not the exported ontology changed the file at filename or not. Source code in turtle_canon/canon.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def export_ontology ( ontology : Graph , filename : Path ) -> bool : \"\"\"Export an ontology as a Turtle file. Parameters: ontology: A loaded ontology. filename: The Turtle file's fully resolved path to export to. Returns: Whether or not the exported ontology changed the file at `filename` or not. \"\"\" if not filename . exists (): raise exceptions . TurtleFileNotFound ( f \"File at { filename } was unexpectedly not found !\" ) with TemporaryDirectory () as tmp_dir : tmp_turtle_file = Path ( tmp_dir ) / \"tmp_turtle_file.ttl\" try : ontology . serialize ( tmp_turtle_file , format = \"turtle\" ) except Exception as exc : raise exceptions . FailedExportToFile ( f \"Failed to properly save the loaded ontology from { filename } to file.\" ) from exc else : canonized_ttl = tmp_turtle_file . read_text ( encoding = \"utf8\" ) if not canonized_ttl or re . match ( r \"^\\s$\" , canonized_ttl ): raise exceptions . FailedExportToFile ( f \"Failed to properly save the loaded ontology from { filename } to file.\" ) changed = filename . read_text () != canonized_ttl filename . write_text ( canonized_ttl , encoding = \"utf8\" ) return changed sort_ontology ( turtle_file ) \u00b6 Load and sort triples in ontology. A validated Turtle file is expected, hence there are no \"unnecessary\" sanity checks in this function. Parameters: Name Type Description Default turtle_file Path A valid pathlib.Path object representing the (unsorted) Turtle file. required Source code in turtle_canon/canon.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def sort_ontology ( turtle_file : Path ) -> Graph : \"\"\"Load and sort triples in ontology. A validated Turtle file is expected, hence there are no \"unnecessary\" sanity checks in this function. Parameters: turtle_file: A valid `pathlib.Path` object representing the (unsorted) Turtle file. \"\"\" try : ontology = Graph () . parse ( location = str ( turtle_file ), format = \"turtle\" ) except Exception as exc : raise exceptions . FailedParsingFile ( f \"Failed to properly parse the Turtle file at { turtle_file } \" ) from exc else : triples = sorted ( ontology ) if not triples : raise warnings . NoTriples ( f \"No triples found in the parsed non-empty Turtle file at { turtle_file } \" ) sorted_ontology = Graph ( namespace_manager = ontology . namespace_manager , base = ontology . base ) try : for triple in triples : sorted_ontology . add ( triple ) except Exception as exc : raise exceptions . FailedCreatingOntology ( \"Failed to properly create a sorted ontology from the triples in the \" f \"Turtle file at { turtle_file } \" ) from exc if set ( ontology ) - set ( sorted_ontology ) or len ( ontology ) != len ( sorted_ontology ): raise exceptions . InconsistencyError ( f \"After sorting the ontology triples from the Turtle file at { turtle_file } \" \" and re-creating the ontology, inconsistencies were found !\" ) return sorted_ontology validate_turtle ( turtle_file ) \u00b6 Validate a Turtle file. Parameters: Name Type Description Default turtle_file Union[Path, str] An absolute path or pathlib.Path object representing the Turtle file location. required Returns: Type Description Path A pathlib.Path object representing a validated Turtle file. Source code in turtle_canon/canon.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def validate_turtle ( turtle_file : \"Union[Path, str]\" ) -> Path : \"\"\"Validate a Turtle file. Parameters: turtle_file: An absolute path or `pathlib.Path` object representing the Turtle file location. Returns: A `pathlib.Path` object representing a validated Turtle file. \"\"\" turtle_file = Path ( turtle_file ) . resolve () if not turtle_file . exists (): raise exceptions . TurtleFileNotFound ( f \"Supplied file { turtle_file } not found.\" ) try : content = turtle_file . read_text ( encoding = \"utf8\" ) except ( OSError , UnicodeDecodeError ) as exc : raise exceptions . FailedReadingFile ( f \"The Turtle file { turtle_file } could not be opened and read (using UTF-8 \" \"encoding).\" ) from exc try : turtle_file . write_text ( content , encoding = \"utf8\" ) except ( OSError , UnicodeDecodeError ) as exc : raise exceptions . FailedReadingFile ( f \"The Turtle file { turtle_file } could not be opened and written to (using \" \"UTF-8 encoding).\" ) from exc if not content : raise warnings . EmptyFile ( f \"The Turtle file { turtle_file } is empty.\" ) return turtle_file","title":"canon"},{"location":"api_reference/canon/#canon","text":"The main turtle-canon module.","title":"canon"},{"location":"api_reference/canon/#turtle_canon.canon.canonize","text":"The main function for running turtle-canon . Workflow: - Validate Turtle file. Check the file integrity, readability, writeability and content. - Parse and sort Turtle file's triples. Parse Turtle file using RDFlib. Retrieve triples, sort them, and generate a new RDFlib Graph from the sorted triples. - Export ontology as Turtle file. Overwriting loaded Turtle file, i.e., overall the canonization is done in-place. Parameters: Name Type Description Default turtle_file Union[Path, str] An absolute path or pathlib.Path object representing the Turtle file location. required Returns: Type Description Union[Path, None] If the file has been changed during the canonization, the Turtle file's Union[Path, None] location will be returned, otherwise None will be returned. Source code in turtle_canon/canon.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def canonize ( turtle_file : \"Union[Path, str]\" ) -> \"Union[Path, None]\" : \"\"\"The main function for running `turtle-canon`. Workflow: - **Validate** Turtle file. Check the file integrity, readability, writeability and content. - **Parse** and **sort** Turtle file's triples. Parse Turtle file using RDFlib. Retrieve triples, sort them, and generate a new RDFlib `Graph` from the sorted triples. - **Export** ontology as Turtle file. Overwriting loaded Turtle file, i.e., overall the canonization is done in-place. Parameters: turtle_file: An absolute path or `pathlib.Path` object representing the Turtle file location. Returns: If the file has been changed during the canonization, the Turtle file's location will be returned, otherwise `None` will be returned. \"\"\" valid_turtle_file = validate_turtle ( turtle_file ) sorted_ontology = sort_ontology ( valid_turtle_file ) changed_file = export_ontology ( sorted_ontology , valid_turtle_file ) return Path ( turtle_file ) if changed_file else None","title":"canonize()"},{"location":"api_reference/canon/#turtle_canon.canon.export_ontology","text":"Export an ontology as a Turtle file. Parameters: Name Type Description Default ontology Graph A loaded ontology. required filename Path The Turtle file's fully resolved path to export to. required Returns: Type Description bool Whether or not the exported ontology changed the file at filename or not. Source code in turtle_canon/canon.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def export_ontology ( ontology : Graph , filename : Path ) -> bool : \"\"\"Export an ontology as a Turtle file. Parameters: ontology: A loaded ontology. filename: The Turtle file's fully resolved path to export to. Returns: Whether or not the exported ontology changed the file at `filename` or not. \"\"\" if not filename . exists (): raise exceptions . TurtleFileNotFound ( f \"File at { filename } was unexpectedly not found !\" ) with TemporaryDirectory () as tmp_dir : tmp_turtle_file = Path ( tmp_dir ) / \"tmp_turtle_file.ttl\" try : ontology . serialize ( tmp_turtle_file , format = \"turtle\" ) except Exception as exc : raise exceptions . FailedExportToFile ( f \"Failed to properly save the loaded ontology from { filename } to file.\" ) from exc else : canonized_ttl = tmp_turtle_file . read_text ( encoding = \"utf8\" ) if not canonized_ttl or re . match ( r \"^\\s$\" , canonized_ttl ): raise exceptions . FailedExportToFile ( f \"Failed to properly save the loaded ontology from { filename } to file.\" ) changed = filename . read_text () != canonized_ttl filename . write_text ( canonized_ttl , encoding = \"utf8\" ) return changed","title":"export_ontology()"},{"location":"api_reference/canon/#turtle_canon.canon.sort_ontology","text":"Load and sort triples in ontology. A validated Turtle file is expected, hence there are no \"unnecessary\" sanity checks in this function. Parameters: Name Type Description Default turtle_file Path A valid pathlib.Path object representing the (unsorted) Turtle file. required Source code in turtle_canon/canon.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def sort_ontology ( turtle_file : Path ) -> Graph : \"\"\"Load and sort triples in ontology. A validated Turtle file is expected, hence there are no \"unnecessary\" sanity checks in this function. Parameters: turtle_file: A valid `pathlib.Path` object representing the (unsorted) Turtle file. \"\"\" try : ontology = Graph () . parse ( location = str ( turtle_file ), format = \"turtle\" ) except Exception as exc : raise exceptions . FailedParsingFile ( f \"Failed to properly parse the Turtle file at { turtle_file } \" ) from exc else : triples = sorted ( ontology ) if not triples : raise warnings . NoTriples ( f \"No triples found in the parsed non-empty Turtle file at { turtle_file } \" ) sorted_ontology = Graph ( namespace_manager = ontology . namespace_manager , base = ontology . base ) try : for triple in triples : sorted_ontology . add ( triple ) except Exception as exc : raise exceptions . FailedCreatingOntology ( \"Failed to properly create a sorted ontology from the triples in the \" f \"Turtle file at { turtle_file } \" ) from exc if set ( ontology ) - set ( sorted_ontology ) or len ( ontology ) != len ( sorted_ontology ): raise exceptions . InconsistencyError ( f \"After sorting the ontology triples from the Turtle file at { turtle_file } \" \" and re-creating the ontology, inconsistencies were found !\" ) return sorted_ontology","title":"sort_ontology()"},{"location":"api_reference/canon/#turtle_canon.canon.validate_turtle","text":"Validate a Turtle file. Parameters: Name Type Description Default turtle_file Union[Path, str] An absolute path or pathlib.Path object representing the Turtle file location. required Returns: Type Description Path A pathlib.Path object representing a validated Turtle file. Source code in turtle_canon/canon.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def validate_turtle ( turtle_file : \"Union[Path, str]\" ) -> Path : \"\"\"Validate a Turtle file. Parameters: turtle_file: An absolute path or `pathlib.Path` object representing the Turtle file location. Returns: A `pathlib.Path` object representing a validated Turtle file. \"\"\" turtle_file = Path ( turtle_file ) . resolve () if not turtle_file . exists (): raise exceptions . TurtleFileNotFound ( f \"Supplied file { turtle_file } not found.\" ) try : content = turtle_file . read_text ( encoding = \"utf8\" ) except ( OSError , UnicodeDecodeError ) as exc : raise exceptions . FailedReadingFile ( f \"The Turtle file { turtle_file } could not be opened and read (using UTF-8 \" \"encoding).\" ) from exc try : turtle_file . write_text ( content , encoding = \"utf8\" ) except ( OSError , UnicodeDecodeError ) as exc : raise exceptions . FailedReadingFile ( f \"The Turtle file { turtle_file } could not be opened and written to (using \" \"UTF-8 encoding).\" ) from exc if not content : raise warnings . EmptyFile ( f \"The Turtle file { turtle_file } is empty.\" ) return turtle_file","title":"validate_turtle()"},{"location":"api_reference/cli/cmd_turtle_canon/","text":"cmd_turtle_canon \u00b6 Command line interface (CLI) for running turtle-canon . CLIArgs dataclass \u00b6 CLI parsed arguments Source code in turtle_canon/cli/cmd_turtle_canon.py 13 14 15 16 17 18 19 20 @dataclass class CLIArgs : \"\"\"CLI parsed arguments\"\"\" version : str log_level : str fail_fast : bool turtle_files : List [ Path ] main ( args = None ) \u00b6 Turtle Canon - It's turtles all the way down. Source code in turtle_canon/cli/cmd_turtle_canon.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def main ( args : \"List[str]\" = None ) -> None : \"\"\"Turtle Canon - It's turtles all the way down.\"\"\" from turtle_canon import __version__ from turtle_canon.canon import canonize from turtle_canon.cli import utils from turtle_canon.utils.exceptions import TurtleCanonException from turtle_canon.utils.warnings import TurtleCanonWarning parser = argparse . ArgumentParser ( description = main . __doc__ , formatter_class = argparse . ArgumentDefaultsHelpFormatter , ) parser . add_argument ( \"--version\" , action = \"version\" , help = \"Show the version and exit.\" , version = f \"Turtle Canon version { __version__ } \" , ) parser . add_argument ( \"--log-level\" , type = str , help = \"Set the logging output level.\" , choices = LOGGING_LEVELS , default = \"info\" , ) parser . add_argument ( \"--fail-fast\" , action = \"store_true\" , help = ( \"Exit the canonization immediately if an error occurs. E.g., if multiple \" \"files are given, Turtle Canon will exit immediately if an error occurs \" \"when canonization a single file. Otherwise, all files will be attempted \" \"to be canonized, and a summary will be printed at the end.\" ), ) parser . add_argument ( \"turtle_files\" , action = \"extend\" , nargs = \"+\" , type = Path , help = ( \"Path to the Turtle file. Can be relative or absolute. Example: \" \"'../my_ontology.ttl'.\" ), metavar = \"TURTLE_FILE\" , ) args : \"CLIArgs\" = parser . parse_args ( args ) # type: ignore[assignment] cache = utils . Cache () number_of_turtle_files = len ( args . turtle_files ) while args . turtle_files : turtle_file = args . turtle_files . pop () changed_file = None try : changed_file = canonize ( turtle_file ) if changed_file : cache . add_file ( changed_file ) except TurtleCanonException as exception : if args . fail_fast : utils . print_error ( exception ) else : cache . add_error ( exception ) except TurtleCanonWarning as warning : if number_of_turtle_files == 1 : utils . print_warning ( warning ) cache . add_warning ( warning ) if changed_file : cache . add_file ( changed_file ) if number_of_turtle_files == 1 and cache . warnings : pass else : utils . print_summary ( errors = cache . errors , warnings = cache . warnings ) utils . print_changed_files ( cache . files , exit_after = bool ( cache . errors )) sys . exit ()","title":"cmd_turtle_canon"},{"location":"api_reference/cli/cmd_turtle_canon/#cmd_turtle_canon","text":"Command line interface (CLI) for running turtle-canon .","title":"cmd_turtle_canon"},{"location":"api_reference/cli/cmd_turtle_canon/#turtle_canon.cli.cmd_turtle_canon.CLIArgs","text":"CLI parsed arguments Source code in turtle_canon/cli/cmd_turtle_canon.py 13 14 15 16 17 18 19 20 @dataclass class CLIArgs : \"\"\"CLI parsed arguments\"\"\" version : str log_level : str fail_fast : bool turtle_files : List [ Path ]","title":"CLIArgs"},{"location":"api_reference/cli/cmd_turtle_canon/#turtle_canon.cli.cmd_turtle_canon.main","text":"Turtle Canon - It's turtles all the way down. Source code in turtle_canon/cli/cmd_turtle_canon.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def main ( args : \"List[str]\" = None ) -> None : \"\"\"Turtle Canon - It's turtles all the way down.\"\"\" from turtle_canon import __version__ from turtle_canon.canon import canonize from turtle_canon.cli import utils from turtle_canon.utils.exceptions import TurtleCanonException from turtle_canon.utils.warnings import TurtleCanonWarning parser = argparse . ArgumentParser ( description = main . __doc__ , formatter_class = argparse . ArgumentDefaultsHelpFormatter , ) parser . add_argument ( \"--version\" , action = \"version\" , help = \"Show the version and exit.\" , version = f \"Turtle Canon version { __version__ } \" , ) parser . add_argument ( \"--log-level\" , type = str , help = \"Set the logging output level.\" , choices = LOGGING_LEVELS , default = \"info\" , ) parser . add_argument ( \"--fail-fast\" , action = \"store_true\" , help = ( \"Exit the canonization immediately if an error occurs. E.g., if multiple \" \"files are given, Turtle Canon will exit immediately if an error occurs \" \"when canonization a single file. Otherwise, all files will be attempted \" \"to be canonized, and a summary will be printed at the end.\" ), ) parser . add_argument ( \"turtle_files\" , action = \"extend\" , nargs = \"+\" , type = Path , help = ( \"Path to the Turtle file. Can be relative or absolute. Example: \" \"'../my_ontology.ttl'.\" ), metavar = \"TURTLE_FILE\" , ) args : \"CLIArgs\" = parser . parse_args ( args ) # type: ignore[assignment] cache = utils . Cache () number_of_turtle_files = len ( args . turtle_files ) while args . turtle_files : turtle_file = args . turtle_files . pop () changed_file = None try : changed_file = canonize ( turtle_file ) if changed_file : cache . add_file ( changed_file ) except TurtleCanonException as exception : if args . fail_fast : utils . print_error ( exception ) else : cache . add_error ( exception ) except TurtleCanonWarning as warning : if number_of_turtle_files == 1 : utils . print_warning ( warning ) cache . add_warning ( warning ) if changed_file : cache . add_file ( changed_file ) if number_of_turtle_files == 1 and cache . warnings : pass else : utils . print_summary ( errors = cache . errors , warnings = cache . warnings ) utils . print_changed_files ( cache . files , exit_after = bool ( cache . errors )) sys . exit ()","title":"main()"},{"location":"api_reference/cli/utils/","text":"utils \u00b6 Utility functions for turtle-canon CLI. Cache \u00b6 Small cache. Source code in turtle_canon/cli/utils.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Cache : \"\"\"Small cache.\"\"\" def __init__ ( self ) -> None : self . _errors : \"List[Union[str, Exception]]\" = [] self . _warnings : \"List[Union[str, Exception]]\" = [] self . _files : \"List[Union[str, Path]]\" = [] @property def errors ( self ) -> \"List[Union[str, Exception]]\" : \"\"\"Get `errors` attribute.\"\"\" return self . _errors @property def warnings ( self ) -> \"List[Union[str, Exception]]\" : \"\"\"Get `warnings` attribute.\"\"\" return self . _warnings @property def files ( self ) -> \"List[Union[str, Path]]\" : \"\"\"Get `files` attribute.\"\"\" return self . _files def add_error ( self , error : \"Union[str, Exception]\" ) -> None : \"\"\"Add an error to the cache.\"\"\" if not isinstance ( error , ( str , Exception )): raise TypeError ( \"error must be either a str or Exception\" ) self . _errors . append ( error ) def add_warning ( self , warning : \"Union[str, Exception]\" ) -> None : \"\"\"Add a warning to the cache.\"\"\" if not isinstance ( warning , ( str , Exception )): raise TypeError ( \"warning must be either a str or Exception\" ) self . _warnings . append ( warning ) def add_file ( self , file : \"Union[str, Path]\" ) -> None : \"\"\"Add a file to the cache.\"\"\" if not isinstance ( file , ( str , Path )): raise TypeError ( \"file must be either a str or Exception\" ) self . _files . append ( file ) add_error ( error ) \u00b6 Add an error to the cache. Source code in turtle_canon/cli/utils.py 33 34 35 36 37 def add_error ( self , error : \"Union[str, Exception]\" ) -> None : \"\"\"Add an error to the cache.\"\"\" if not isinstance ( error , ( str , Exception )): raise TypeError ( \"error must be either a str or Exception\" ) self . _errors . append ( error ) add_file ( file ) \u00b6 Add a file to the cache. Source code in turtle_canon/cli/utils.py 45 46 47 48 49 def add_file ( self , file : \"Union[str, Path]\" ) -> None : \"\"\"Add a file to the cache.\"\"\" if not isinstance ( file , ( str , Path )): raise TypeError ( \"file must be either a str or Exception\" ) self . _files . append ( file ) add_warning ( warning ) \u00b6 Add a warning to the cache. Source code in turtle_canon/cli/utils.py 39 40 41 42 43 def add_warning ( self , warning : \"Union[str, Exception]\" ) -> None : \"\"\"Add a warning to the cache.\"\"\" if not isinstance ( warning , ( str , Exception )): raise TypeError ( \"warning must be either a str or Exception\" ) self . _warnings . append ( warning ) errors () property \u00b6 Get errors attribute. Source code in turtle_canon/cli/utils.py 18 19 20 21 @property def errors ( self ) -> \"List[Union[str, Exception]]\" : \"\"\"Get `errors` attribute.\"\"\" return self . _errors files () property \u00b6 Get files attribute. Source code in turtle_canon/cli/utils.py 28 29 30 31 @property def files ( self ) -> \"List[Union[str, Path]]\" : \"\"\"Get `files` attribute.\"\"\" return self . _files warnings () property \u00b6 Get warnings attribute. Source code in turtle_canon/cli/utils.py 23 24 25 26 @property def warnings ( self ) -> \"List[Union[str, Exception]]\" : \"\"\"Get `warnings` attribute.\"\"\" return self . _warnings print_changed_files ( files , exit_after = False ) \u00b6 Print list of changed files. Parameters: Name Type Description Default files Sequence[Union[str, Path]] List of files with changes. required exit_after bool Whether or not to call sys.exit(1) after printing the message. False Source code in turtle_canon/cli/utils.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def print_changed_files ( files : \"Sequence[Union[str, Path]]\" , exit_after : bool = False ) -> None : \"\"\"Print list of changed files. Parameters: files: List of files with changes. exit_after: Whether or not to call `sys.exit(1)` after printing the message. \"\"\" res = \" \\n Changed files: \\n \" for file_ in files : res += f \" { file_ } \\n \" _print_message ( res , target = sys . stdout , prefix = \"\" , exit_after = exit_after ) print_error ( message , exit_after = True ) \u00b6 Print an error message to the console. Parameters: Name Type Description Default message Union[str, Exception] The error message to print. required exit_after bool Whether or not to call sys.exit(1) after printing the message. True Source code in turtle_canon/cli/utils.py 75 76 77 78 79 80 81 82 83 84 85 86 def print_error ( message : \"Union[str, Exception]\" , exit_after : bool = True ) -> None : \"\"\"Print an error message to the console. Parameters: message: The error message to print. exit_after: Whether or not to call `sys.exit(1)` after printing the message. \"\"\" res = f \"Misfire ! \\n\\n { message } \" if isinstance ( message , Exception ): res += f \" \\n\\n General information about the exception: { message . __doc__ } \" _print_message ( res , target = sys . stderr , prefix = \"ERROR: \" , exit_after = exit_after ) print_summary ( errors = None , warnings = None , exit_after = False ) \u00b6 Print a summary, including of error and/or warning messages. Parameters: Name Type Description Default errors Optional[Sequence[Union[str, Exception]]] List of error messages. None warnings Optional[Sequence[Union[str, Exception]]] List of warning messages. None exit_after bool Whether or not to call sys.exit(1) after printing the message. False Source code in turtle_canon/cli/utils.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def print_summary ( errors : \"Optional[Sequence[Union[str, Exception]]]\" = None , warnings : \"Optional[Sequence[Union[str, Exception]]]\" = None , exit_after : bool = False , ) -> None : \"\"\"Print a summary, including of error and/or warning messages. Parameters: errors: List of error messages. warnings: List of warning messages. exit_after: Whether or not to call `sys.exit(1)` after printing the message. \"\"\" res = \"\" target = sys . stdout if errors or warnings : res += \"The balls are stuck ! \\n\\n \" target = sys . stderr else : res += \"Successful Fire ! \\n \" if errors : res += \"ERRORS: \\n \" for error in errors : res += f \"* { error } \\n \" if isinstance ( error , Exception ): res += f \" General info: { error . __doc__ } \\n \" if warnings : res += \"WARNINGS: \\n \" for warning in warnings : res += f \"* { warning } \\n \" if isinstance ( warning , Exception ): res += f \" General info: { warning . __doc__ } \\n \" _print_message ( res [: - 1 ], target = target , prefix = \"\" , exit_after = exit_after ) print_warning ( message , exit_after = False ) \u00b6 Print a warnings message to the console. Parameters: Name Type Description Default message Union[str, Exception] The warning message to print. required exit_after bool Whether or not to call sys.exit(1) after printing the message. False Source code in turtle_canon/cli/utils.py 89 90 91 92 93 94 95 96 97 98 99 100 def print_warning ( message : \"Union[str, Exception]\" , exit_after : bool = False ) -> None : \"\"\"Print a warnings message to the console. Parameters: message: The warning message to print. exit_after: Whether or not to call `sys.exit(1)` after printing the message. \"\"\" res = f \"Don't come too close ! \\n\\n { message } \" if isinstance ( message , Exception ): res += f \" \\n\\n General information about the warning: { message . __doc__ } \" _print_message ( res , target = sys . stderr , prefix = \"WARNING: \" , exit_after = exit_after )","title":"utils"},{"location":"api_reference/cli/utils/#utils","text":"Utility functions for turtle-canon CLI.","title":"utils"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.Cache","text":"Small cache. Source code in turtle_canon/cli/utils.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Cache : \"\"\"Small cache.\"\"\" def __init__ ( self ) -> None : self . _errors : \"List[Union[str, Exception]]\" = [] self . _warnings : \"List[Union[str, Exception]]\" = [] self . _files : \"List[Union[str, Path]]\" = [] @property def errors ( self ) -> \"List[Union[str, Exception]]\" : \"\"\"Get `errors` attribute.\"\"\" return self . _errors @property def warnings ( self ) -> \"List[Union[str, Exception]]\" : \"\"\"Get `warnings` attribute.\"\"\" return self . _warnings @property def files ( self ) -> \"List[Union[str, Path]]\" : \"\"\"Get `files` attribute.\"\"\" return self . _files def add_error ( self , error : \"Union[str, Exception]\" ) -> None : \"\"\"Add an error to the cache.\"\"\" if not isinstance ( error , ( str , Exception )): raise TypeError ( \"error must be either a str or Exception\" ) self . _errors . append ( error ) def add_warning ( self , warning : \"Union[str, Exception]\" ) -> None : \"\"\"Add a warning to the cache.\"\"\" if not isinstance ( warning , ( str , Exception )): raise TypeError ( \"warning must be either a str or Exception\" ) self . _warnings . append ( warning ) def add_file ( self , file : \"Union[str, Path]\" ) -> None : \"\"\"Add a file to the cache.\"\"\" if not isinstance ( file , ( str , Path )): raise TypeError ( \"file must be either a str or Exception\" ) self . _files . append ( file )","title":"Cache"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.Cache.add_error","text":"Add an error to the cache. Source code in turtle_canon/cli/utils.py 33 34 35 36 37 def add_error ( self , error : \"Union[str, Exception]\" ) -> None : \"\"\"Add an error to the cache.\"\"\" if not isinstance ( error , ( str , Exception )): raise TypeError ( \"error must be either a str or Exception\" ) self . _errors . append ( error )","title":"add_error()"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.Cache.add_file","text":"Add a file to the cache. Source code in turtle_canon/cli/utils.py 45 46 47 48 49 def add_file ( self , file : \"Union[str, Path]\" ) -> None : \"\"\"Add a file to the cache.\"\"\" if not isinstance ( file , ( str , Path )): raise TypeError ( \"file must be either a str or Exception\" ) self . _files . append ( file )","title":"add_file()"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.Cache.add_warning","text":"Add a warning to the cache. Source code in turtle_canon/cli/utils.py 39 40 41 42 43 def add_warning ( self , warning : \"Union[str, Exception]\" ) -> None : \"\"\"Add a warning to the cache.\"\"\" if not isinstance ( warning , ( str , Exception )): raise TypeError ( \"warning must be either a str or Exception\" ) self . _warnings . append ( warning )","title":"add_warning()"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.Cache.errors","text":"Get errors attribute. Source code in turtle_canon/cli/utils.py 18 19 20 21 @property def errors ( self ) -> \"List[Union[str, Exception]]\" : \"\"\"Get `errors` attribute.\"\"\" return self . _errors","title":"errors()"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.Cache.files","text":"Get files attribute. Source code in turtle_canon/cli/utils.py 28 29 30 31 @property def files ( self ) -> \"List[Union[str, Path]]\" : \"\"\"Get `files` attribute.\"\"\" return self . _files","title":"files()"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.Cache.warnings","text":"Get warnings attribute. Source code in turtle_canon/cli/utils.py 23 24 25 26 @property def warnings ( self ) -> \"List[Union[str, Exception]]\" : \"\"\"Get `warnings` attribute.\"\"\" return self . _warnings","title":"warnings()"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.print_changed_files","text":"Print list of changed files. Parameters: Name Type Description Default files Sequence[Union[str, Path]] List of files with changes. required exit_after bool Whether or not to call sys.exit(1) after printing the message. False Source code in turtle_canon/cli/utils.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def print_changed_files ( files : \"Sequence[Union[str, Path]]\" , exit_after : bool = False ) -> None : \"\"\"Print list of changed files. Parameters: files: List of files with changes. exit_after: Whether or not to call `sys.exit(1)` after printing the message. \"\"\" res = \" \\n Changed files: \\n \" for file_ in files : res += f \" { file_ } \\n \" _print_message ( res , target = sys . stdout , prefix = \"\" , exit_after = exit_after )","title":"print_changed_files()"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.print_error","text":"Print an error message to the console. Parameters: Name Type Description Default message Union[str, Exception] The error message to print. required exit_after bool Whether or not to call sys.exit(1) after printing the message. True Source code in turtle_canon/cli/utils.py 75 76 77 78 79 80 81 82 83 84 85 86 def print_error ( message : \"Union[str, Exception]\" , exit_after : bool = True ) -> None : \"\"\"Print an error message to the console. Parameters: message: The error message to print. exit_after: Whether or not to call `sys.exit(1)` after printing the message. \"\"\" res = f \"Misfire ! \\n\\n { message } \" if isinstance ( message , Exception ): res += f \" \\n\\n General information about the exception: { message . __doc__ } \" _print_message ( res , target = sys . stderr , prefix = \"ERROR: \" , exit_after = exit_after )","title":"print_error()"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.print_summary","text":"Print a summary, including of error and/or warning messages. Parameters: Name Type Description Default errors Optional[Sequence[Union[str, Exception]]] List of error messages. None warnings Optional[Sequence[Union[str, Exception]]] List of warning messages. None exit_after bool Whether or not to call sys.exit(1) after printing the message. False Source code in turtle_canon/cli/utils.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def print_summary ( errors : \"Optional[Sequence[Union[str, Exception]]]\" = None , warnings : \"Optional[Sequence[Union[str, Exception]]]\" = None , exit_after : bool = False , ) -> None : \"\"\"Print a summary, including of error and/or warning messages. Parameters: errors: List of error messages. warnings: List of warning messages. exit_after: Whether or not to call `sys.exit(1)` after printing the message. \"\"\" res = \"\" target = sys . stdout if errors or warnings : res += \"The balls are stuck ! \\n\\n \" target = sys . stderr else : res += \"Successful Fire ! \\n \" if errors : res += \"ERRORS: \\n \" for error in errors : res += f \"* { error } \\n \" if isinstance ( error , Exception ): res += f \" General info: { error . __doc__ } \\n \" if warnings : res += \"WARNINGS: \\n \" for warning in warnings : res += f \"* { warning } \\n \" if isinstance ( warning , Exception ): res += f \" General info: { warning . __doc__ } \\n \" _print_message ( res [: - 1 ], target = target , prefix = \"\" , exit_after = exit_after )","title":"print_summary()"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.print_warning","text":"Print a warnings message to the console. Parameters: Name Type Description Default message Union[str, Exception] The warning message to print. required exit_after bool Whether or not to call sys.exit(1) after printing the message. False Source code in turtle_canon/cli/utils.py 89 90 91 92 93 94 95 96 97 98 99 100 def print_warning ( message : \"Union[str, Exception]\" , exit_after : bool = False ) -> None : \"\"\"Print a warnings message to the console. Parameters: message: The warning message to print. exit_after: Whether or not to call `sys.exit(1)` after printing the message. \"\"\" res = f \"Don't come too close ! \\n\\n { message } \" if isinstance ( message , Exception ): res += f \" \\n\\n General information about the warning: { message . __doc__ } \" _print_message ( res , target = sys . stderr , prefix = \"WARNING: \" , exit_after = exit_after )","title":"print_warning()"},{"location":"api_reference/utils/exceptions/","text":"exceptions \u00b6 Exceptions for general usage by the Turtle Canon tool. FailedCreatingOntology \u00b6 Bases: TurtleCanonException RDFlib failed to add one or more triples to a new rdflib.Graph object. Source code in turtle_canon/utils/exceptions.py 28 29 class FailedCreatingOntology ( TurtleCanonException ): \"\"\"RDFlib failed to add one or more triples to a new `rdflib.Graph` object.\"\"\" FailedExportToFile \u00b6 Bases: TurtleCanonException Failed to export an ontology to file. Source code in turtle_canon/utils/exceptions.py 12 13 class FailedExportToFile ( TurtleCanonException ): \"\"\"Failed to export an ontology to file.\"\"\" FailedParsingFile \u00b6 Bases: TurtleCanonException RDFlib failed parsing a Turtle file. Source code in turtle_canon/utils/exceptions.py 24 25 class FailedParsingFile ( TurtleCanonException ): \"\"\"RDFlib failed parsing a Turtle file.\"\"\" FailedReadingFile \u00b6 Bases: TurtleCanonException Failed to read the content of a Turtle file using UTF-8 encoding. Source code in turtle_canon/utils/exceptions.py 16 17 class FailedReadingFile ( TurtleCanonException ): \"\"\"Failed to read the content of a Turtle file using UTF-8 encoding.\"\"\" InconsistencyError \u00b6 Bases: TurtleCanonException An inconsistency was found. Source code in turtle_canon/utils/exceptions.py 20 21 class InconsistencyError ( TurtleCanonException ): \"\"\"An inconsistency was found.\"\"\" TurtleCanonException \u00b6 Bases: Exception Base Exception for the Turtle Canon tool. Source code in turtle_canon/utils/exceptions.py 4 5 class TurtleCanonException ( Exception ): \"\"\"Base Exception for the Turtle Canon tool.\"\"\" TurtleFileNotFound \u00b6 Bases: TurtleCanonException A Turtle file cannot be found. Source code in turtle_canon/utils/exceptions.py 8 9 class TurtleFileNotFound ( TurtleCanonException ): \"\"\"A Turtle file cannot be found.\"\"\"","title":"exceptions"},{"location":"api_reference/utils/exceptions/#exceptions","text":"Exceptions for general usage by the Turtle Canon tool.","title":"exceptions"},{"location":"api_reference/utils/exceptions/#turtle_canon.utils.exceptions.FailedCreatingOntology","text":"Bases: TurtleCanonException RDFlib failed to add one or more triples to a new rdflib.Graph object. Source code in turtle_canon/utils/exceptions.py 28 29 class FailedCreatingOntology ( TurtleCanonException ): \"\"\"RDFlib failed to add one or more triples to a new `rdflib.Graph` object.\"\"\"","title":"FailedCreatingOntology"},{"location":"api_reference/utils/exceptions/#turtle_canon.utils.exceptions.FailedExportToFile","text":"Bases: TurtleCanonException Failed to export an ontology to file. Source code in turtle_canon/utils/exceptions.py 12 13 class FailedExportToFile ( TurtleCanonException ): \"\"\"Failed to export an ontology to file.\"\"\"","title":"FailedExportToFile"},{"location":"api_reference/utils/exceptions/#turtle_canon.utils.exceptions.FailedParsingFile","text":"Bases: TurtleCanonException RDFlib failed parsing a Turtle file. Source code in turtle_canon/utils/exceptions.py 24 25 class FailedParsingFile ( TurtleCanonException ): \"\"\"RDFlib failed parsing a Turtle file.\"\"\"","title":"FailedParsingFile"},{"location":"api_reference/utils/exceptions/#turtle_canon.utils.exceptions.FailedReadingFile","text":"Bases: TurtleCanonException Failed to read the content of a Turtle file using UTF-8 encoding. Source code in turtle_canon/utils/exceptions.py 16 17 class FailedReadingFile ( TurtleCanonException ): \"\"\"Failed to read the content of a Turtle file using UTF-8 encoding.\"\"\"","title":"FailedReadingFile"},{"location":"api_reference/utils/exceptions/#turtle_canon.utils.exceptions.InconsistencyError","text":"Bases: TurtleCanonException An inconsistency was found. Source code in turtle_canon/utils/exceptions.py 20 21 class InconsistencyError ( TurtleCanonException ): \"\"\"An inconsistency was found.\"\"\"","title":"InconsistencyError"},{"location":"api_reference/utils/exceptions/#turtle_canon.utils.exceptions.TurtleCanonException","text":"Bases: Exception Base Exception for the Turtle Canon tool. Source code in turtle_canon/utils/exceptions.py 4 5 class TurtleCanonException ( Exception ): \"\"\"Base Exception for the Turtle Canon tool.\"\"\"","title":"TurtleCanonException"},{"location":"api_reference/utils/exceptions/#turtle_canon.utils.exceptions.TurtleFileNotFound","text":"Bases: TurtleCanonException A Turtle file cannot be found. Source code in turtle_canon/utils/exceptions.py 8 9 class TurtleFileNotFound ( TurtleCanonException ): \"\"\"A Turtle file cannot be found.\"\"\"","title":"TurtleFileNotFound"},{"location":"api_reference/utils/warnings/","text":"warnings \u00b6 Warnings for general usage by the Turtle Canon tool. Note These warnings are not like regular Python Warning s. Instead, they are Exception s that will be caught and treated specially by the CLI. EmptyFile \u00b6 Bases: TurtleCanonWarning A file's content is empty. Source code in turtle_canon/utils/warnings.py 14 15 class EmptyFile ( TurtleCanonWarning ): \"\"\"A file's content is empty.\"\"\" NoTriples \u00b6 Bases: TurtleCanonWarning No triples found in the parsed ontology. Source code in turtle_canon/utils/warnings.py 18 19 class NoTriples ( TurtleCanonWarning ): \"\"\"No triples found in the parsed ontology.\"\"\" TurtleCanonWarning \u00b6 Bases: Exception Base Warning for the Turtle Canon tool. Source code in turtle_canon/utils/warnings.py 10 11 class TurtleCanonWarning ( Exception ): \"\"\"Base Warning for the Turtle Canon tool.\"\"\"","title":"warnings"},{"location":"api_reference/utils/warnings/#warnings","text":"Warnings for general usage by the Turtle Canon tool. Note These warnings are not like regular Python Warning s. Instead, they are Exception s that will be caught and treated specially by the CLI.","title":"warnings"},{"location":"api_reference/utils/warnings/#turtle_canon.utils.warnings.EmptyFile","text":"Bases: TurtleCanonWarning A file's content is empty. Source code in turtle_canon/utils/warnings.py 14 15 class EmptyFile ( TurtleCanonWarning ): \"\"\"A file's content is empty.\"\"\"","title":"EmptyFile"},{"location":"api_reference/utils/warnings/#turtle_canon.utils.warnings.NoTriples","text":"Bases: TurtleCanonWarning No triples found in the parsed ontology. Source code in turtle_canon/utils/warnings.py 18 19 class NoTriples ( TurtleCanonWarning ): \"\"\"No triples found in the parsed ontology.\"\"\"","title":"NoTriples"},{"location":"api_reference/utils/warnings/#turtle_canon.utils.warnings.TurtleCanonWarning","text":"Bases: Exception Base Warning for the Turtle Canon tool. Source code in turtle_canon/utils/warnings.py 10 11 class TurtleCanonWarning ( Exception ): \"\"\"Base Warning for the Turtle Canon tool.\"\"\"","title":"TurtleCanonWarning"}]}