{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Turtle Canon \u00b6 It's turtles all the way down A tool for canonizing Turtle ( .ttl ) ontology files. The domain standardized tool for editing and creating ontologies is Prot\u00e9g\u00e9 . The Turtle ( .ttl ) file format is a format based on XML and OWL, which is considered one of the most readable formats for OWL ontology files. However, Prot\u00e9g\u00e9 writes the order of ontology entities differently depending on the version, this tool mitigates this by running the file through a canonizing parser that ensures the classes are sorted and listed in the same way, always. The main use case for developing this tool is when developing ontologies utilizing versioning tools such as git , svn or similar, which are single character diff-sensitive. Install \u00b6 The tool is written for Python 3.9, so one needs at minimum Python 3.9 installed to run it at this stage. The plan is to make a stand-alone executable for each of the major OS'. Install via PyPI (stable version, recommended): python3.9 -m pip install turtle-canon Install via GitHub (development version): python3.9 -m pip install git+https://github.com/CasperWA/turtle-canon#egg = turtle-canon Usage \u00b6 To run the tool, simply run: turtle-canon path/to/my_ontology_file.ttl For more information about the tool and the options available, run turtle-canon --help . To check the version run turtle-canon --version . The currently latest stable version is 0.0.1 . License & copyright \u00b6 This tool is MIT Licensed and copyright \u00a9 2021 Casper Welzel Andersen ( GitHub , GitLab , website ) & SINTEF.","title":"Turtle Canon"},{"location":"#turtle-canon","text":"It's turtles all the way down A tool for canonizing Turtle ( .ttl ) ontology files. The domain standardized tool for editing and creating ontologies is Prot\u00e9g\u00e9 . The Turtle ( .ttl ) file format is a format based on XML and OWL, which is considered one of the most readable formats for OWL ontology files. However, Prot\u00e9g\u00e9 writes the order of ontology entities differently depending on the version, this tool mitigates this by running the file through a canonizing parser that ensures the classes are sorted and listed in the same way, always. The main use case for developing this tool is when developing ontologies utilizing versioning tools such as git , svn or similar, which are single character diff-sensitive.","title":"Turtle Canon"},{"location":"#install","text":"The tool is written for Python 3.9, so one needs at minimum Python 3.9 installed to run it at this stage. The plan is to make a stand-alone executable for each of the major OS'. Install via PyPI (stable version, recommended): python3.9 -m pip install turtle-canon Install via GitHub (development version): python3.9 -m pip install git+https://github.com/CasperWA/turtle-canon#egg = turtle-canon","title":"Install"},{"location":"#usage","text":"To run the tool, simply run: turtle-canon path/to/my_ontology_file.ttl For more information about the tool and the options available, run turtle-canon --help . To check the version run turtle-canon --version . The currently latest stable version is 0.0.1 .","title":"Usage"},{"location":"#license-copyright","text":"This tool is MIT Licensed and copyright \u00a9 2021 Casper Welzel Andersen ( GitHub , GitLab , website ) & SINTEF.","title":"License &amp; copyright"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2021 Casper Welzel Andersen & SINTEF Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"LICENSE"},{"location":"design/","text":"Design outline \u00b6 As outlined on the landing page, the goal of the Turtle Canon tool is to canonize (or standardize) the Turtle ontology files exported by, especially, Prot\u00e9g\u00e9 . To achieve this, RDFlib is utilized to load in the Turtle file as a rdflib.Graph object, retrieving all the triples, sorting them, creating an empty, new rdflib.Graph object, add the sorted list of triples, and then export the ontology as a Turtle file, overwriting the original Turtle file. In this process, precautions are taken to ensure the Turtle file is only overwritten if everything has gone as expected and an extensive validation of the input Turtle file is undertaken before even parsing it as a rdflib.Graph object. Same ontology - different generation tools \u00b6 For the use case of having the same ontology, but in a logically different state, e.g., when triples may be added upon reasoning an ontology, but it is still considered to be the same ontology, the canonization process falters. It falters in the sense that Turtle Canon considers the provided list of triples to be the ultimate source of truth for canonization. Turtle Canon will not try to reason or infer what set of triples have been added during a reasoning process, and which were the \"original\". It will instead merely retrieve the list of triples, sort them, and export them as a Turtle file, overwriting the source Turtle file. diff tool \u00b6 It is the intention to add a diff -like tool for these events, where the differing set of triples are listed when comparing two Turtle files. From there, adding functionality to interactively manipulate which triples should be created or removed should be somewhat straight-forward. The intention is to add exactly this, however, the exact design for this has not yet been determined. The initial point of this tool is to help users be aware that changes have occurred between two ontologies, what they are, and understand whether they are semantic or logical.","title":"Design outline"},{"location":"design/#design-outline","text":"As outlined on the landing page, the goal of the Turtle Canon tool is to canonize (or standardize) the Turtle ontology files exported by, especially, Prot\u00e9g\u00e9 . To achieve this, RDFlib is utilized to load in the Turtle file as a rdflib.Graph object, retrieving all the triples, sorting them, creating an empty, new rdflib.Graph object, add the sorted list of triples, and then export the ontology as a Turtle file, overwriting the original Turtle file. In this process, precautions are taken to ensure the Turtle file is only overwritten if everything has gone as expected and an extensive validation of the input Turtle file is undertaken before even parsing it as a rdflib.Graph object.","title":"Design outline"},{"location":"design/#same-ontology-different-generation-tools","text":"For the use case of having the same ontology, but in a logically different state, e.g., when triples may be added upon reasoning an ontology, but it is still considered to be the same ontology, the canonization process falters. It falters in the sense that Turtle Canon considers the provided list of triples to be the ultimate source of truth for canonization. Turtle Canon will not try to reason or infer what set of triples have been added during a reasoning process, and which were the \"original\". It will instead merely retrieve the list of triples, sort them, and export them as a Turtle file, overwriting the source Turtle file.","title":"Same ontology - different generation tools"},{"location":"design/#diff-tool","text":"It is the intention to add a diff -like tool for these events, where the differing set of triples are listed when comparing two Turtle files. From there, adding functionality to interactively manipulate which triples should be created or removed should be somewhat straight-forward. The intention is to add exactly this, however, the exact design for this has not yet been determined. The initial point of this tool is to help users be aware that changes have occurred between two ontologies, what they are, and understand whether they are semantic or logical.","title":"diff tool"},{"location":"api_reference/canon/","text":"canon \u00b6 The main turtle-canon module. canonize ( turtle_file ) \u00b6 The main function for running turtle-canon . Workflow: - Validate Turtle file. Check the file integrity, readability, writeability and content. - Parse and sort Turtle file's triples. Parse Turtle file using RDFlib. Retrieve triples, sort them, and generate a new RDFlib Graph from the sorted triples. - Export ontology as Turtle file. Overwriting loaded Turtle file, i.e., overall the canonization is done in-place. Parameters: Name Type Description Default turtle_file Union[Path, str] An absolute path or pathlib.Path object representing the Turtle file location. required Source code in turtle_canon/canon.py def canonize ( turtle_file : \"Union[Path, str]\" ) -> None : \"\"\"The main function for running `turtle-canon`. Workflow: - **Validate** Turtle file. Check the file integrity, readability, writeability and content. - **Parse** and **sort** Turtle file's triples. Parse Turtle file using RDFlib. Retrieve triples, sort them, and generate a new RDFlib `Graph` from the sorted triples. - **Export** ontology as Turtle file. Overwriting loaded Turtle file, i.e., overall the canonization is done in-place. Parameters: turtle_file: An absolute path or `pathlib.Path` object representing the Turtle file location. \"\"\" valid_turtle_file = validate_turtle ( turtle_file ) sorted_ontology = sort_ontology ( valid_turtle_file ) export_ontology ( sorted_ontology , valid_turtle_file ) export_ontology ( ontology , filename ) \u00b6 Export an ontology as a Turtle file. Parameters: Name Type Description Default ontology Graph A loaded ontology. required filename Path The Turtle file's fully resolved path to export to. required Source code in turtle_canon/canon.py def export_ontology ( ontology : Graph , filename : Path ) -> None : \"\"\"Export an ontology as a Turtle file. Parameters: ontology: A loaded ontology. filename: The Turtle file's fully resolved path to export to. \"\"\" if not filename . exists (): raise exceptions . TurtleFileNotFound ( f \"File at { filename } was unexpectedly not found !\" ) with TemporaryDirectory () as tmp_dir : tmp_turtle_file = Path ( tmp_dir ) / \"tmp_turtle_file.ttl\" try : ontology . serialize ( tmp_turtle_file , format = \"turtle\" ) except Exception as exc : raise exceptions . FailedExportToFile ( f \"Failed to properly save the loaded ontology from { filename } to file.\" ) from exc else : canonized_ttl = tmp_turtle_file . read_text ( encoding = \"utf8\" ) if not canonized_ttl or re . match ( r \"^\\s$\" , canonized_ttl ): raise exceptions . FailedExportToFile ( f \"Failed to properly save the loaded ontology from { filename } to file.\" ) filename . write_text ( canonized_ttl , encoding = \"utf8\" ) sort_ontology ( turtle_file ) \u00b6 Load and sort triples in ontology. A validated Turtle file is expected, hence there are no \"unnecessary\" sanity checks in this function. Parameters: Name Type Description Default turtle_file Path A valid pathlib.Path object representing the (unsorted) Turtle file. required Source code in turtle_canon/canon.py def sort_ontology ( turtle_file : Path ) -> Graph : \"\"\"Load and sort triples in ontology. A validated Turtle file is expected, hence there are no \"unnecessary\" sanity checks in this function. Parameters: turtle_file: A valid `pathlib.Path` object representing the (unsorted) Turtle file. \"\"\" try : ontology = Graph () . parse ( location = str ( turtle_file ), format = \"turtle\" ) except Exception as exc : raise exceptions . FailedParsingFile ( f \"Failed to properly parse the Turtle file at { turtle_file } \" ) from exc else : triples = sorted ( ontology ) if not triples : raise warnings . NoTriples ( f \"No triples found in the parsed non-empty Turtle file at { turtle_file } \" ) sorted_ontology = Graph ( namespace_manager = ontology . namespace_manager , base = ontology . base ) try : for triple in triples : sorted_ontology . add ( triple ) except Exception as exc : raise exceptions . FailedCreatingOntology ( \"Failed to properly create a sorted ontology from the triples in the \" f \"Turtle file at { turtle_file } \" ) from exc if set ( ontology ) - set ( sorted_ontology ) or len ( ontology ) != len ( sorted_ontology ): raise exceptions . InconsistencyError ( f \"After sorting the ontology triples from the Turtle file at { turtle_file } \" \" and re-creating the ontology, inconsistencies were found !\" ) return sorted_ontology validate_turtle ( turtle_file ) \u00b6 Validate a Turtle file. Parameters: Name Type Description Default turtle_file Union[Path, str] An absolute path or pathlib.Path object representing the Turtle file location. required Returns: Type Description Path A pathlib.Path object representing a validated Turtle file. Source code in turtle_canon/canon.py def validate_turtle ( turtle_file : \"Union[Path, str]\" ) -> Path : \"\"\"Validate a Turtle file. Parameters: turtle_file: An absolute path or `pathlib.Path` object representing the Turtle file location. Returns: A `pathlib.Path` object representing a validated Turtle file. \"\"\" turtle_file = Path ( turtle_file ) . resolve () if not turtle_file . exists (): raise exceptions . TurtleFileNotFound ( f \"Supplied file { turtle_file } not found.\" ) try : content = turtle_file . read_text ( encoding = \"utf8\" ) except ( OSError , UnicodeDecodeError ) as exc : raise exceptions . FailedReadingFile ( f \"The Turtle file { turtle_file } could not be opened and read (using UTF-8 \" \"encoding).\" ) from exc try : turtle_file . write_text ( content , encoding = \"utf8\" ) except ( OSError , UnicodeDecodeError ) as exc : raise exceptions . FailedReadingFile ( f \"The Turtle file { turtle_file } could not be opened and written to (using \" \"UTF-8 encoding).\" ) from exc if not content : raise warnings . EmptyFile ( f \"The Turtle file { turtle_file } is empty.\" ) return turtle_file","title":"canon"},{"location":"api_reference/canon/#canon","text":"The main turtle-canon module.","title":"canon"},{"location":"api_reference/canon/#turtle_canon.canon.canonize","text":"The main function for running turtle-canon . Workflow: - Validate Turtle file. Check the file integrity, readability, writeability and content. - Parse and sort Turtle file's triples. Parse Turtle file using RDFlib. Retrieve triples, sort them, and generate a new RDFlib Graph from the sorted triples. - Export ontology as Turtle file. Overwriting loaded Turtle file, i.e., overall the canonization is done in-place. Parameters: Name Type Description Default turtle_file Union[Path, str] An absolute path or pathlib.Path object representing the Turtle file location. required Source code in turtle_canon/canon.py def canonize ( turtle_file : \"Union[Path, str]\" ) -> None : \"\"\"The main function for running `turtle-canon`. Workflow: - **Validate** Turtle file. Check the file integrity, readability, writeability and content. - **Parse** and **sort** Turtle file's triples. Parse Turtle file using RDFlib. Retrieve triples, sort them, and generate a new RDFlib `Graph` from the sorted triples. - **Export** ontology as Turtle file. Overwriting loaded Turtle file, i.e., overall the canonization is done in-place. Parameters: turtle_file: An absolute path or `pathlib.Path` object representing the Turtle file location. \"\"\" valid_turtle_file = validate_turtle ( turtle_file ) sorted_ontology = sort_ontology ( valid_turtle_file ) export_ontology ( sorted_ontology , valid_turtle_file )","title":"canonize()"},{"location":"api_reference/canon/#turtle_canon.canon.export_ontology","text":"Export an ontology as a Turtle file. Parameters: Name Type Description Default ontology Graph A loaded ontology. required filename Path The Turtle file's fully resolved path to export to. required Source code in turtle_canon/canon.py def export_ontology ( ontology : Graph , filename : Path ) -> None : \"\"\"Export an ontology as a Turtle file. Parameters: ontology: A loaded ontology. filename: The Turtle file's fully resolved path to export to. \"\"\" if not filename . exists (): raise exceptions . TurtleFileNotFound ( f \"File at { filename } was unexpectedly not found !\" ) with TemporaryDirectory () as tmp_dir : tmp_turtle_file = Path ( tmp_dir ) / \"tmp_turtle_file.ttl\" try : ontology . serialize ( tmp_turtle_file , format = \"turtle\" ) except Exception as exc : raise exceptions . FailedExportToFile ( f \"Failed to properly save the loaded ontology from { filename } to file.\" ) from exc else : canonized_ttl = tmp_turtle_file . read_text ( encoding = \"utf8\" ) if not canonized_ttl or re . match ( r \"^\\s$\" , canonized_ttl ): raise exceptions . FailedExportToFile ( f \"Failed to properly save the loaded ontology from { filename } to file.\" ) filename . write_text ( canonized_ttl , encoding = \"utf8\" )","title":"export_ontology()"},{"location":"api_reference/canon/#turtle_canon.canon.sort_ontology","text":"Load and sort triples in ontology. A validated Turtle file is expected, hence there are no \"unnecessary\" sanity checks in this function. Parameters: Name Type Description Default turtle_file Path A valid pathlib.Path object representing the (unsorted) Turtle file. required Source code in turtle_canon/canon.py def sort_ontology ( turtle_file : Path ) -> Graph : \"\"\"Load and sort triples in ontology. A validated Turtle file is expected, hence there are no \"unnecessary\" sanity checks in this function. Parameters: turtle_file: A valid `pathlib.Path` object representing the (unsorted) Turtle file. \"\"\" try : ontology = Graph () . parse ( location = str ( turtle_file ), format = \"turtle\" ) except Exception as exc : raise exceptions . FailedParsingFile ( f \"Failed to properly parse the Turtle file at { turtle_file } \" ) from exc else : triples = sorted ( ontology ) if not triples : raise warnings . NoTriples ( f \"No triples found in the parsed non-empty Turtle file at { turtle_file } \" ) sorted_ontology = Graph ( namespace_manager = ontology . namespace_manager , base = ontology . base ) try : for triple in triples : sorted_ontology . add ( triple ) except Exception as exc : raise exceptions . FailedCreatingOntology ( \"Failed to properly create a sorted ontology from the triples in the \" f \"Turtle file at { turtle_file } \" ) from exc if set ( ontology ) - set ( sorted_ontology ) or len ( ontology ) != len ( sorted_ontology ): raise exceptions . InconsistencyError ( f \"After sorting the ontology triples from the Turtle file at { turtle_file } \" \" and re-creating the ontology, inconsistencies were found !\" ) return sorted_ontology","title":"sort_ontology()"},{"location":"api_reference/canon/#turtle_canon.canon.validate_turtle","text":"Validate a Turtle file. Parameters: Name Type Description Default turtle_file Union[Path, str] An absolute path or pathlib.Path object representing the Turtle file location. required Returns: Type Description Path A pathlib.Path object representing a validated Turtle file. Source code in turtle_canon/canon.py def validate_turtle ( turtle_file : \"Union[Path, str]\" ) -> Path : \"\"\"Validate a Turtle file. Parameters: turtle_file: An absolute path or `pathlib.Path` object representing the Turtle file location. Returns: A `pathlib.Path` object representing a validated Turtle file. \"\"\" turtle_file = Path ( turtle_file ) . resolve () if not turtle_file . exists (): raise exceptions . TurtleFileNotFound ( f \"Supplied file { turtle_file } not found.\" ) try : content = turtle_file . read_text ( encoding = \"utf8\" ) except ( OSError , UnicodeDecodeError ) as exc : raise exceptions . FailedReadingFile ( f \"The Turtle file { turtle_file } could not be opened and read (using UTF-8 \" \"encoding).\" ) from exc try : turtle_file . write_text ( content , encoding = \"utf8\" ) except ( OSError , UnicodeDecodeError ) as exc : raise exceptions . FailedReadingFile ( f \"The Turtle file { turtle_file } could not be opened and written to (using \" \"UTF-8 encoding).\" ) from exc if not content : raise warnings . EmptyFile ( f \"The Turtle file { turtle_file } is empty.\" ) return turtle_file","title":"validate_turtle()"},{"location":"api_reference/cli/cmd_turtle_canon/","text":"cmd_turtle_canon \u00b6 Command line interface (CLI) for running turtle-canon . main ( args = None ) \u00b6 Turtle Canon - It's turtles all the way down. Source code in turtle_canon/cli/cmd_turtle_canon.py def main ( args : \"List[str]\" = None ) -> None : \"\"\"Turtle Canon - It's turtles all the way down.\"\"\" from turtle_canon import __version__ from turtle_canon.canon import canonize from turtle_canon.cli.utils import print_error , print_summary , print_warning from turtle_canon.utils.exceptions import TurtleCanonException from turtle_canon.utils.warnings import TurtleCanonWarning parser = argparse . ArgumentParser ( description = main . __doc__ , formatter_class = argparse . ArgumentDefaultsHelpFormatter , ) parser . add_argument ( \"--version\" , action = \"version\" , help = \"Show the version and exit.\" , version = f \"Turtle Canon version { __version__ } \" , ) parser . add_argument ( \"--log-level\" , type = str , help = \"Set the logging output level.\" , choices = LOGGING_LEVELS , default = \"info\" , ) parser . add_argument ( \"--fail-fast\" , action = \"store_true\" , help = ( \"Exit the canonization immediately if an error occurs. E.g., if multiple \" \"files are given, Turtle Canon will exit immediately if an error occurs \" \"when canonization a single file. Otherwise, all files will be attempted \" \"to be canonized, and a summary will be printed at the end.\" ), ) parser . add_argument ( \"turtle_files\" , action = \"extend\" , nargs = \"+\" , type = Path , help = ( \"Path to the Turtle file. Can be relative or absolute. Example: \" \"'../my_ontology.ttl'.\" ), metavar = \"TURTLE_FILE\" , ) args : \"CLIArgs\" = parser . parse_args ( args ) # type: ignore[assignment] errors = [] warnings = [] number_of_turtle_files = len ( args . turtle_files ) while args . turtle_files : turtle_file = args . turtle_files . pop () try : canonize ( turtle_file ) except TurtleCanonException as exception : if args . fail_fast : print_error ( exception ) else : errors . append ( exception ) except TurtleCanonWarning as warning : if number_of_turtle_files == 1 : print_warning ( warning ) warnings . append ( warning ) if number_of_turtle_files == 1 and warnings : pass else : print_summary ( errors = errors , warnings = warnings ) sys . exit ()","title":"cmd_turtle_canon"},{"location":"api_reference/cli/cmd_turtle_canon/#cmd_turtle_canon","text":"Command line interface (CLI) for running turtle-canon .","title":"cmd_turtle_canon"},{"location":"api_reference/cli/cmd_turtle_canon/#turtle_canon.cli.cmd_turtle_canon.main","text":"Turtle Canon - It's turtles all the way down. Source code in turtle_canon/cli/cmd_turtle_canon.py def main ( args : \"List[str]\" = None ) -> None : \"\"\"Turtle Canon - It's turtles all the way down.\"\"\" from turtle_canon import __version__ from turtle_canon.canon import canonize from turtle_canon.cli.utils import print_error , print_summary , print_warning from turtle_canon.utils.exceptions import TurtleCanonException from turtle_canon.utils.warnings import TurtleCanonWarning parser = argparse . ArgumentParser ( description = main . __doc__ , formatter_class = argparse . ArgumentDefaultsHelpFormatter , ) parser . add_argument ( \"--version\" , action = \"version\" , help = \"Show the version and exit.\" , version = f \"Turtle Canon version { __version__ } \" , ) parser . add_argument ( \"--log-level\" , type = str , help = \"Set the logging output level.\" , choices = LOGGING_LEVELS , default = \"info\" , ) parser . add_argument ( \"--fail-fast\" , action = \"store_true\" , help = ( \"Exit the canonization immediately if an error occurs. E.g., if multiple \" \"files are given, Turtle Canon will exit immediately if an error occurs \" \"when canonization a single file. Otherwise, all files will be attempted \" \"to be canonized, and a summary will be printed at the end.\" ), ) parser . add_argument ( \"turtle_files\" , action = \"extend\" , nargs = \"+\" , type = Path , help = ( \"Path to the Turtle file. Can be relative or absolute. Example: \" \"'../my_ontology.ttl'.\" ), metavar = \"TURTLE_FILE\" , ) args : \"CLIArgs\" = parser . parse_args ( args ) # type: ignore[assignment] errors = [] warnings = [] number_of_turtle_files = len ( args . turtle_files ) while args . turtle_files : turtle_file = args . turtle_files . pop () try : canonize ( turtle_file ) except TurtleCanonException as exception : if args . fail_fast : print_error ( exception ) else : errors . append ( exception ) except TurtleCanonWarning as warning : if number_of_turtle_files == 1 : print_warning ( warning ) warnings . append ( warning ) if number_of_turtle_files == 1 and warnings : pass else : print_summary ( errors = errors , warnings = warnings ) sys . exit ()","title":"main()"},{"location":"api_reference/cli/utils/","text":"utils \u00b6 Utility functions for turtle-canon CLI. print_error ( message , exit_after = True ) \u00b6 Print an error message to the console. Parameters: Name Type Description Default message Union[str, Exception] The error message to print. required exit_after bool Whether or not to call sys.exit(1) after printing the message. True Source code in turtle_canon/cli/utils.py def print_error ( message : \"Union[str, Exception]\" , exit_after : bool = True ) -> None : \"\"\"Print an error message to the console. Parameters: message: The error message to print. exit_after: Whether or not to call `sys.exit(1)` after printing the message. \"\"\" res = f \"Misfire ! \\n\\n { message } \" if isinstance ( message , Exception ): res += f \" \\n\\n General information about the exception: { message . __doc__ } \" _print_message ( res , target = sys . stderr , prefix = \"ERROR: \" , exit_after = exit_after ) print_summary ( errors = None , warnings = None , exit_after = True ) \u00b6 Print a summary, including of error and/or warning messages. Parameters: Name Type Description Default errors Optional[Sequence[Union[str, Exception]]] List of error messages. None warnings Optional[Sequence[Union[str, Exception]]] List of warning messages. None exit_after bool Whether or not to call sys.exit(1) after printing the message. True Source code in turtle_canon/cli/utils.py def print_summary ( errors : \"Optional[Sequence[Union[str, Exception]]]\" = None , warnings : \"Optional[Sequence[Union[str, Exception]]]\" = None , exit_after : bool = True , ) -> None : \"\"\"Print a summary, including of error and/or warning messages. Parameters: errors: List of error messages. warnings: List of warning messages. exit_after: Whether or not to call `sys.exit(1)` after printing the message. \"\"\" exit_after = bool ( errors ) res = \"\" target = sys . stdout if errors or warnings : res += \"The balls are stuck ! \\n\\n \" target = sys . stderr else : res += \"Successful Fire !\" if errors : res += \"ERRORS: \\n \" for error in errors : res += f \"* { error } \\n \" if isinstance ( error , Exception ): res += f \" General info: { error . __doc__ } \\n \" if warnings : res += \"WARNINGS: \\n \" for warning in warnings : res += f \"* { warning } \\n \" if isinstance ( warning , Exception ): res += f \" General info: { warning . __doc__ } \\n \" _print_message ( res , target = target , prefix = \"\" , exit_after = exit_after ) print_warning ( message , exit_after = False ) \u00b6 Print a warnings message to the console. Parameters: Name Type Description Default message Union[str, Exception] The warning message to print. required exit_after bool Whether or not to call sys.exit(1) after printing the message. False Source code in turtle_canon/cli/utils.py def print_warning ( message : \"Union[str, Exception]\" , exit_after : bool = False ) -> None : \"\"\"Print a warnings message to the console. Parameters: message: The warning message to print. exit_after: Whether or not to call `sys.exit(1)` after printing the message. \"\"\" res = f \"Don't come too close ! \\n\\n { message } \" if isinstance ( message , Exception ): res += f \" \\n\\n General information about the warning: { message . __doc__ } \" _print_message ( res , target = sys . stderr , prefix = \"WARNING: \" , exit_after = exit_after )","title":"utils"},{"location":"api_reference/cli/utils/#utils","text":"Utility functions for turtle-canon CLI.","title":"utils"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.print_error","text":"Print an error message to the console. Parameters: Name Type Description Default message Union[str, Exception] The error message to print. required exit_after bool Whether or not to call sys.exit(1) after printing the message. True Source code in turtle_canon/cli/utils.py def print_error ( message : \"Union[str, Exception]\" , exit_after : bool = True ) -> None : \"\"\"Print an error message to the console. Parameters: message: The error message to print. exit_after: Whether or not to call `sys.exit(1)` after printing the message. \"\"\" res = f \"Misfire ! \\n\\n { message } \" if isinstance ( message , Exception ): res += f \" \\n\\n General information about the exception: { message . __doc__ } \" _print_message ( res , target = sys . stderr , prefix = \"ERROR: \" , exit_after = exit_after )","title":"print_error()"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.print_summary","text":"Print a summary, including of error and/or warning messages. Parameters: Name Type Description Default errors Optional[Sequence[Union[str, Exception]]] List of error messages. None warnings Optional[Sequence[Union[str, Exception]]] List of warning messages. None exit_after bool Whether or not to call sys.exit(1) after printing the message. True Source code in turtle_canon/cli/utils.py def print_summary ( errors : \"Optional[Sequence[Union[str, Exception]]]\" = None , warnings : \"Optional[Sequence[Union[str, Exception]]]\" = None , exit_after : bool = True , ) -> None : \"\"\"Print a summary, including of error and/or warning messages. Parameters: errors: List of error messages. warnings: List of warning messages. exit_after: Whether or not to call `sys.exit(1)` after printing the message. \"\"\" exit_after = bool ( errors ) res = \"\" target = sys . stdout if errors or warnings : res += \"The balls are stuck ! \\n\\n \" target = sys . stderr else : res += \"Successful Fire !\" if errors : res += \"ERRORS: \\n \" for error in errors : res += f \"* { error } \\n \" if isinstance ( error , Exception ): res += f \" General info: { error . __doc__ } \\n \" if warnings : res += \"WARNINGS: \\n \" for warning in warnings : res += f \"* { warning } \\n \" if isinstance ( warning , Exception ): res += f \" General info: { warning . __doc__ } \\n \" _print_message ( res , target = target , prefix = \"\" , exit_after = exit_after )","title":"print_summary()"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.print_warning","text":"Print a warnings message to the console. Parameters: Name Type Description Default message Union[str, Exception] The warning message to print. required exit_after bool Whether or not to call sys.exit(1) after printing the message. False Source code in turtle_canon/cli/utils.py def print_warning ( message : \"Union[str, Exception]\" , exit_after : bool = False ) -> None : \"\"\"Print a warnings message to the console. Parameters: message: The warning message to print. exit_after: Whether or not to call `sys.exit(1)` after printing the message. \"\"\" res = f \"Don't come too close ! \\n\\n { message } \" if isinstance ( message , Exception ): res += f \" \\n\\n General information about the warning: { message . __doc__ } \" _print_message ( res , target = sys . stderr , prefix = \"WARNING: \" , exit_after = exit_after )","title":"print_warning()"},{"location":"api_reference/utils/exceptions/","text":"exceptions \u00b6 Exceptions for general usage by the Turtle Canon tool. FailedCreatingOntology ( TurtleCanonException ) \u00b6 RDFlib failed to add one or more triples to a new rdflib.Graph object. Source code in turtle_canon/utils/exceptions.py class FailedCreatingOntology ( TurtleCanonException ): \"\"\"RDFlib failed to add one or more triples to a new `rdflib.Graph` object.\"\"\" FailedExportToFile ( TurtleCanonException ) \u00b6 Failed to export an ontology to file. Source code in turtle_canon/utils/exceptions.py class FailedExportToFile ( TurtleCanonException ): \"\"\"Failed to export an ontology to file.\"\"\" FailedParsingFile ( TurtleCanonException ) \u00b6 RDFlib failed parsing a Turtle file. Source code in turtle_canon/utils/exceptions.py class FailedParsingFile ( TurtleCanonException ): \"\"\"RDFlib failed parsing a Turtle file.\"\"\" FailedReadingFile ( TurtleCanonException ) \u00b6 Failed to read the content of a Turtle file using UTF-8 encoding. Source code in turtle_canon/utils/exceptions.py class FailedReadingFile ( TurtleCanonException ): \"\"\"Failed to read the content of a Turtle file using UTF-8 encoding.\"\"\" InconsistencyError ( TurtleCanonException ) \u00b6 An inconsistency was found. Source code in turtle_canon/utils/exceptions.py class InconsistencyError ( TurtleCanonException ): \"\"\"An inconsistency was found.\"\"\" TurtleCanonException ( Exception ) \u00b6 Base Exception for the Turtle Canon tool. Source code in turtle_canon/utils/exceptions.py class TurtleCanonException ( Exception ): \"\"\"Base Exception for the Turtle Canon tool.\"\"\" TurtleFileNotFound ( TurtleCanonException ) \u00b6 A Turtle file cannot be found. Source code in turtle_canon/utils/exceptions.py class TurtleFileNotFound ( TurtleCanonException ): \"\"\"A Turtle file cannot be found.\"\"\"","title":"exceptions"},{"location":"api_reference/utils/exceptions/#exceptions","text":"Exceptions for general usage by the Turtle Canon tool.","title":"exceptions"},{"location":"api_reference/utils/exceptions/#turtle_canon.utils.exceptions.FailedCreatingOntology","text":"RDFlib failed to add one or more triples to a new rdflib.Graph object. Source code in turtle_canon/utils/exceptions.py class FailedCreatingOntology ( TurtleCanonException ): \"\"\"RDFlib failed to add one or more triples to a new `rdflib.Graph` object.\"\"\"","title":"FailedCreatingOntology"},{"location":"api_reference/utils/exceptions/#turtle_canon.utils.exceptions.FailedExportToFile","text":"Failed to export an ontology to file. Source code in turtle_canon/utils/exceptions.py class FailedExportToFile ( TurtleCanonException ): \"\"\"Failed to export an ontology to file.\"\"\"","title":"FailedExportToFile"},{"location":"api_reference/utils/exceptions/#turtle_canon.utils.exceptions.FailedParsingFile","text":"RDFlib failed parsing a Turtle file. Source code in turtle_canon/utils/exceptions.py class FailedParsingFile ( TurtleCanonException ): \"\"\"RDFlib failed parsing a Turtle file.\"\"\"","title":"FailedParsingFile"},{"location":"api_reference/utils/exceptions/#turtle_canon.utils.exceptions.FailedReadingFile","text":"Failed to read the content of a Turtle file using UTF-8 encoding. Source code in turtle_canon/utils/exceptions.py class FailedReadingFile ( TurtleCanonException ): \"\"\"Failed to read the content of a Turtle file using UTF-8 encoding.\"\"\"","title":"FailedReadingFile"},{"location":"api_reference/utils/exceptions/#turtle_canon.utils.exceptions.InconsistencyError","text":"An inconsistency was found. Source code in turtle_canon/utils/exceptions.py class InconsistencyError ( TurtleCanonException ): \"\"\"An inconsistency was found.\"\"\"","title":"InconsistencyError"},{"location":"api_reference/utils/exceptions/#turtle_canon.utils.exceptions.TurtleCanonException","text":"Base Exception for the Turtle Canon tool. Source code in turtle_canon/utils/exceptions.py class TurtleCanonException ( Exception ): \"\"\"Base Exception for the Turtle Canon tool.\"\"\"","title":"TurtleCanonException"},{"location":"api_reference/utils/exceptions/#turtle_canon.utils.exceptions.TurtleFileNotFound","text":"A Turtle file cannot be found. Source code in turtle_canon/utils/exceptions.py class TurtleFileNotFound ( TurtleCanonException ): \"\"\"A Turtle file cannot be found.\"\"\"","title":"TurtleFileNotFound"},{"location":"api_reference/utils/warnings/","text":"warnings \u00b6 Warnings for general usage by the Turtle Canon tool. Note These warnings are not like regular Python Warning s. Instead, they are Exception s that will be caught and treated specially by the CLI. EmptyFile ( TurtleCanonWarning ) \u00b6 A file's content is empty. Source code in turtle_canon/utils/warnings.py class EmptyFile ( TurtleCanonWarning ): \"\"\"A file's content is empty.\"\"\" NoTriples ( TurtleCanonWarning ) \u00b6 No triples found in the parsed ontology. Source code in turtle_canon/utils/warnings.py class NoTriples ( TurtleCanonWarning ): \"\"\"No triples found in the parsed ontology.\"\"\" TurtleCanonWarning ( Exception ) \u00b6 Base Warning for the Turtle Canon tool. Source code in turtle_canon/utils/warnings.py class TurtleCanonWarning ( Exception ): \"\"\"Base Warning for the Turtle Canon tool.\"\"\"","title":"warnings"},{"location":"api_reference/utils/warnings/#warnings","text":"Warnings for general usage by the Turtle Canon tool. Note These warnings are not like regular Python Warning s. Instead, they are Exception s that will be caught and treated specially by the CLI.","title":"warnings"},{"location":"api_reference/utils/warnings/#turtle_canon.utils.warnings.EmptyFile","text":"A file's content is empty. Source code in turtle_canon/utils/warnings.py class EmptyFile ( TurtleCanonWarning ): \"\"\"A file's content is empty.\"\"\"","title":"EmptyFile"},{"location":"api_reference/utils/warnings/#turtle_canon.utils.warnings.NoTriples","text":"No triples found in the parsed ontology. Source code in turtle_canon/utils/warnings.py class NoTriples ( TurtleCanonWarning ): \"\"\"No triples found in the parsed ontology.\"\"\"","title":"NoTriples"},{"location":"api_reference/utils/warnings/#turtle_canon.utils.warnings.TurtleCanonWarning","text":"Base Warning for the Turtle Canon tool. Source code in turtle_canon/utils/warnings.py class TurtleCanonWarning ( Exception ): \"\"\"Base Warning for the Turtle Canon tool.\"\"\"","title":"TurtleCanonWarning"}]}