{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Turtle Canon","text":"<p>It's turtles all the way down</p> <p> </p> <p>A tool for canonizing Turtle (<code>.ttl</code>) ontology files.</p> <p>The domain standardized tool for editing and creating ontologies is Prot\u00e9g\u00e9. The Turtle (<code>.ttl</code>) file format is a format based on XML and OWL, which is considered one of the most readable formats for OWL ontology files. However, Prot\u00e9g\u00e9 writes the order of ontology entities differently depending on the version, this tool mitigates this by running the file through a canonizing parser that ensures the classes are sorted and listed in the same way, always.</p> <p>The main use case for developing this tool is when developing ontologies utilizing versioning tools such as <code>git</code>, <code>svn</code> or similar, which are single character diff-sensitive.</p>"},{"location":"#install","title":"Install","text":"<p>The tool is written for Python 3.10, so one needs at minimum Python 3.10 installed to run it at this stage. The plan is to make a stand-alone executable for each of the major OS'.</p> <p>Install via PyPI (stable version, recommended):</p> <pre><code>python3.10 -m pip install turtle-canon\n</code></pre> <p>Install via GitHub (development version):</p> <pre><code>python3.10 -m pip install git+https://github.com/CasperWA/turtle-canon#egg=turtle-canon\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>To run the tool, simply run:</p> <pre><code>turtle-canon path/to/my_ontology_file.ttl\n</code></pre> <p>For more information about the tool and the options available, run <code>turtle-canon --help</code>. To check the version run <code>turtle-canon --version</code>.</p> <p>The currently latest stable version is 0.1.1.</p>"},{"location":"#license-copyright","title":"License &amp; copyright","text":"<p>This tool is MIT Licensed and copyright \u00a9 2021 Casper Welzel Andersen (GitHub, GitLab, website) &amp; SINTEF.</p>"},{"location":"LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2021-2025 Casper Welzel Andersen &amp; SINTEF</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"design/","title":"Design outline","text":"<p>As outlined on the landing page, the goal of the Turtle Canon tool is to canonize (or standardize) the Turtle ontology files exported by, especially, Prot\u00e9g\u00e9.</p> <p>To achieve this, RDFlib is utilized to load in the Turtle file as a <code>rdflib.Graph</code> object, retrieving all the triples, sorting them, creating an empty, new <code>rdflib.Graph</code> object, add the sorted list of triples, and then export the ontology as a Turtle file, overwriting the original Turtle file.</p> <p>In this process, precautions are taken to ensure the Turtle file is only overwritten if everything has gone as expected and an extensive validation of the input Turtle file is undertaken before even parsing it as a <code>rdflib.Graph</code> object.</p>"},{"location":"design/#same-ontology-different-generation-tools","title":"Same ontology - different generation tools","text":"<p>For the use case of having the same ontology, but in a logically different state, e.g., when triples may be added upon reasoning an ontology, but it is still considered to be the same ontology, the canonization process falters. It falters in the sense that Turtle Canon considers the provided list of triples to be the ultimate source of truth for canonization. Turtle Canon will not try to reason or infer what set of triples have been added during a reasoning process, and which were the \"original\". It will instead merely retrieve the list of triples, sort them, and export them as a Turtle file, overwriting the source Turtle file.</p>"},{"location":"design/#diff-tool","title":"<code>diff</code> tool","text":"<p>It is the intention to add a <code>diff</code>-like tool for these events, where the differing set of triples are listed when comparing two Turtle files.</p> <p>From there, adding functionality to interactively manipulate which triples should be created or removed should be somewhat straight-forward. The intention is to add exactly this, however, the exact design for this has not yet been determined.</p> <p>The initial point of this tool is to help users be aware that changes have occurred between two ontologies, what they are, and understand whether they are semantic or logical.</p>"},{"location":"api_reference/canon/","title":"canon","text":"<p>The main <code>turtle-canon</code> module.</p>"},{"location":"api_reference/canon/#turtle_canon.canon.canonize","title":"<code>canonize(turtle_file)</code>","text":"<p>The main function for running <code>turtle-canon</code>.</p> <p>Workflow:</p> <ul> <li>Validate Turtle file.   Check the file integrity, readability, writeability and content.</li> <li>Parse and sort Turtle file's triples.   Parse Turtle file using RDFlib.   Retrieve triples, sort them, and generate a new RDFlib <code>Graph</code> from the sorted   triples.</li> <li>Export ontology as Turtle file.   Overwriting loaded Turtle file, i.e., overall the canonization is done in-place.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>turtle_file</code> <code>Path | str</code> <p>An absolute path or <code>pathlib.Path</code> object representing the Turtle file location.</p> required <p>Returns:</p> Type Description <code>Path | None</code> <p>If the file has been changed during the canonization, the Turtle file's</p> <code>Path | None</code> <p>location will be returned, otherwise <code>None</code> will be returned.</p> Source code in <code>turtle_canon/canon.py</code> <pre><code>def canonize(turtle_file: Path | str) -&gt; Path | None:\n    \"\"\"The main function for running `turtle-canon`.\n\n    Workflow:\n\n    - **Validate** Turtle file.\n      Check the file integrity, readability, writeability and content.\n    - **Parse** and **sort** Turtle file's triples.\n      Parse Turtle file using RDFlib.\n      Retrieve triples, sort them, and generate a new RDFlib `Graph` from the sorted\n      triples.\n    - **Export** ontology as Turtle file.\n      Overwriting loaded Turtle file, i.e., overall the canonization is done in-place.\n\n    Parameters:\n        turtle_file: An absolute path or `pathlib.Path` object representing the Turtle\n            file location.\n\n    Returns:\n        If the file has been changed during the canonization, the Turtle file's\n        location will be returned, otherwise `None` will be returned.\n\n    \"\"\"\n    valid_turtle_file = validate_turtle(turtle_file)\n    sorted_ontology = sort_ontology(valid_turtle_file)\n    changed_file = export_ontology(sorted_ontology, valid_turtle_file)\n\n    return Path(turtle_file) if changed_file else None\n</code></pre>"},{"location":"api_reference/canon/#turtle_canon.canon.export_ontology","title":"<code>export_ontology(ontology, filename)</code>","text":"<p>Export an ontology as a Turtle file.</p> <p>Parameters:</p> Name Type Description Default <code>ontology</code> <code>Graph</code> <p>A loaded ontology.</p> required <code>filename</code> <code>Path</code> <p>The Turtle file's fully resolved path to export to.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not the exported ontology changed the file at <code>filename</code> or not.</p> Source code in <code>turtle_canon/canon.py</code> <pre><code>def export_ontology(ontology: Graph, filename: Path) -&gt; bool:\n    \"\"\"Export an ontology as a Turtle file.\n\n    Parameters:\n        ontology: A loaded ontology.\n        filename: The Turtle file's fully resolved path to export to.\n\n    Returns:\n        Whether or not the exported ontology changed the file at `filename` or not.\n\n    \"\"\"\n    if not filename.exists():\n        raise exceptions.TurtleFileNotFound(\n            f\"File at {filename} was unexpectedly not found !\"\n        )\n\n    with TemporaryDirectory() as tmp_dir:\n        tmp_turtle_file = Path(tmp_dir) / \"tmp_turtle_file.ttl\"\n        try:\n            ontology.serialize(tmp_turtle_file, format=\"turtle\")\n        except (ValueError, RDFlibError) as exc:\n            raise exceptions.FailedExportToFile(\n                f\"Failed to properly save the loaded ontology from {filename} to file.\"\n            ) from exc\n\n        canonized_ttl = tmp_turtle_file.read_text(encoding=\"utf8\")\n\n    if not canonized_ttl or re.match(r\"^\\s$\", canonized_ttl):\n        raise exceptions.FailedExportToFile(\n            f\"Failed to properly save the loaded ontology from {filename} to file.\"\n        )\n\n    changed = filename.read_text() != canonized_ttl\n\n    filename.write_text(canonized_ttl, encoding=\"utf8\")\n\n    return changed\n</code></pre>"},{"location":"api_reference/canon/#turtle_canon.canon.sort_ontology","title":"<code>sort_ontology(turtle_file)</code>","text":"<p>Load and sort triples in ontology.</p> <p>A validated Turtle file is expected, hence there are no \"unnecessary\" sanity checks in this function.</p> <p>Parameters:</p> Name Type Description Default <code>turtle_file</code> <code>Path</code> <p>A valid <code>pathlib.Path</code> object representing the (unsorted) Turtle file.</p> required Source code in <code>turtle_canon/canon.py</code> <pre><code>def sort_ontology(turtle_file: Path) -&gt; Graph:\n    \"\"\"Load and sort triples in ontology.\n\n    A validated Turtle file is expected, hence there are no \"unnecessary\" sanity checks\n    in this function.\n\n    Parameters:\n        turtle_file: A valid `pathlib.Path` object representing the (unsorted) Turtle\n            file.\n\n    \"\"\"\n    try:\n        ontology = Graph().parse(location=str(turtle_file), format=\"turtle\")\n    except (SyntaxError, PermissionError, ParserError, RDFlibError) as exc:\n        raise exceptions.FailedParsingFile(\n            f\"Failed to properly parse the Turtle file at {turtle_file}\"\n        ) from exc\n\n    triples = sorted(ontology)\n\n    if not triples:\n        raise warnings.NoTriples(\n            f\"No triples found in the parsed non-empty Turtle file at {turtle_file}\"\n        )\n\n    sorted_ontology = Graph(\n        namespace_manager=ontology.namespace_manager, base=ontology.base\n    )\n    try:\n        for triple in triples:\n            sorted_ontology.add(triple)\n    except (AssertionError, RDFlibError) as exc:\n        raise exceptions.FailedCreatingOntology(\n            \"Failed to properly create a sorted ontology from the triples in the \"\n            f\"Turtle file at {turtle_file}\"\n        ) from exc\n\n    if set(ontology) - set(sorted_ontology) or len(ontology) != len(sorted_ontology):\n        raise exceptions.InconsistencyError(\n            f\"After sorting the ontology triples from the Turtle file at {turtle_file}\"\n            \" and re-creating the ontology, inconsistencies were found !\"\n        )\n\n    return sorted_ontology\n</code></pre>"},{"location":"api_reference/canon/#turtle_canon.canon.validate_turtle","title":"<code>validate_turtle(turtle_file)</code>","text":"<p>Validate a Turtle file.</p> <p>Parameters:</p> Name Type Description Default <code>turtle_file</code> <code>Path | str</code> <p>An absolute path or <code>pathlib.Path</code> object representing the Turtle file location.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>A <code>pathlib.Path</code> object representing a validated Turtle file.</p> Source code in <code>turtle_canon/canon.py</code> <pre><code>def validate_turtle(turtle_file: Path | str) -&gt; Path:\n    \"\"\"Validate a Turtle file.\n\n    Parameters:\n        turtle_file: An absolute path or `pathlib.Path` object representing the Turtle\n            file location.\n\n    Returns:\n        A `pathlib.Path` object representing a validated Turtle file.\n\n    \"\"\"\n    turtle_file = Path(turtle_file).resolve()\n\n    if not turtle_file.exists():\n        raise exceptions.TurtleFileNotFound(f\"Supplied file {turtle_file} not found.\")\n\n    try:\n        content = turtle_file.read_text(encoding=\"utf8\")\n    except (OSError, UnicodeDecodeError) as exc:\n        raise exceptions.FailedReadingFile(\n            f\"The Turtle file {turtle_file} could not be opened and read (using UTF-8 \"\n            \"encoding).\"\n        ) from exc\n\n    try:\n        turtle_file.write_text(content, encoding=\"utf8\")\n    except (OSError, UnicodeDecodeError) as exc:\n        raise exceptions.FailedReadingFile(\n            f\"The Turtle file {turtle_file} could not be opened and written to (using \"\n            \"UTF-8 encoding).\"\n        ) from exc\n\n    if not content:\n        raise warnings.EmptyFile(f\"The Turtle file {turtle_file} is empty.\")\n\n    return turtle_file\n</code></pre>"},{"location":"api_reference/cli/cmd_turtle_canon/","title":"cmd_turtle_canon","text":"<p>Command line interface (CLI) for running <code>turtle-canon</code>.</p>"},{"location":"api_reference/cli/cmd_turtle_canon/#turtle_canon.cli.cmd_turtle_canon.CLIArgs","title":"<code>CLIArgs</code>  <code>dataclass</code>","text":"<p>CLI parsed arguments</p> Source code in <code>turtle_canon/cli/cmd_turtle_canon.py</code> <pre><code>@dataclass\nclass CLIArgs:\n    \"\"\"CLI parsed arguments\"\"\"\n\n    version: str\n    log_level: str\n    fail_fast: bool\n    turtle_files: list[Path]\n</code></pre>"},{"location":"api_reference/cli/cmd_turtle_canon/#turtle_canon.cli.cmd_turtle_canon.main","title":"<code>main(args=None)</code>","text":"<p>Turtle Canon - It's turtles all the way down.</p> Source code in <code>turtle_canon/cli/cmd_turtle_canon.py</code> <pre><code>def main(args: list[str] | None = None) -&gt; None:\n    \"\"\"Turtle Canon - It's turtles all the way down.\"\"\"\n    from turtle_canon import __version__\n    from turtle_canon.canon import canonize\n    from turtle_canon.cli import utils\n    from turtle_canon.utils.exceptions import TurtleCanonException\n    from turtle_canon.utils.warnings import TurtleCanonWarning\n\n    parser = argparse.ArgumentParser(\n        description=main.__doc__,\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n    )\n    parser.add_argument(\n        \"--version\",\n        action=\"version\",\n        help=\"Show the version and exit.\",\n        version=f\"Turtle Canon version {__version__}\",\n    )\n    parser.add_argument(\n        \"--log-level\",\n        type=str,\n        help=\"Set the logging output level.\",\n        choices=LOGGING_LEVELS,\n        default=\"info\",\n    )\n    parser.add_argument(\n        \"--fail-fast\",\n        action=\"store_true\",\n        help=(\n            \"Exit the canonization immediately if an error occurs. E.g., if multiple \"\n            \"files are given, Turtle Canon will exit immediately if an error occurs \"\n            \"when canonization a single file. Otherwise, all files will be attempted \"\n            \"to be canonized, and a summary will be printed at the end.\"\n        ),\n    )\n    parser.add_argument(\n        \"turtle_files\",\n        action=\"extend\",\n        nargs=\"+\",\n        type=Path,\n        help=(\n            \"Path to the Turtle file. Can be relative or absolute. Example: \"\n            \"'../my_ontology.ttl'.\"\n        ),\n        metavar=\"TURTLE_FILE\",\n    )\n\n    args: CLIArgs = parser.parse_args(args)  # type: ignore[assignment]\n\n    cache = utils.Cache()\n\n    number_of_turtle_files = len(args.turtle_files)\n\n    while args.turtle_files:\n        turtle_file = args.turtle_files.pop()\n        changed_file = None\n        try:\n            changed_file = canonize(turtle_file)\n            if changed_file:\n                cache.add_file(changed_file)\n        except TurtleCanonException as exception:\n            if args.fail_fast:\n                utils.print_error(exception)\n            else:\n                cache.add_error(exception)\n        except TurtleCanonWarning as warning:\n            if number_of_turtle_files == 1:\n                utils.print_warning(warning)\n            cache.add_warning(warning)\n            if changed_file:\n                cache.add_file(changed_file)\n\n    if number_of_turtle_files == 1 and cache.warnings:\n        pass\n    else:\n        utils.print_summary(errors=cache.errors, warnings=cache.warnings)\n\n    utils.print_changed_files(cache.files, exit_after=bool(cache.errors))\n\n    sys.exit()\n</code></pre>"},{"location":"api_reference/cli/utils/","title":"utils","text":"<p>Utility functions for <code>turtle-canon</code> CLI.</p>"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.Cache","title":"<code>Cache</code>","text":"<p>Small cache.</p> Source code in <code>turtle_canon/cli/utils.py</code> <pre><code>class Cache:\n    \"\"\"Small cache.\"\"\"\n\n    def __init__(self) -&gt; None:\n        self._errors: list[str | Exception] = []\n        self._warnings: list[str | Exception] = []\n        self._files: list[str | Path] = []\n\n    @property\n    def errors(self) -&gt; list[str | Exception]:\n        \"\"\"Get `errors` attribute.\"\"\"\n        return self._errors\n\n    @property\n    def warnings(self) -&gt; list[str | Exception]:\n        \"\"\"Get `warnings` attribute.\"\"\"\n        return self._warnings\n\n    @property\n    def files(self) -&gt; list[str | Path]:\n        \"\"\"Get `files` attribute.\"\"\"\n        return self._files\n\n    def add_error(self, error: str | Exception) -&gt; None:\n        \"\"\"Add an error to the cache.\"\"\"\n        if not isinstance(error, (str, Exception)):\n            raise TypeError(\"error must be either a str or Exception\")\n        self._errors.append(error)\n\n    def add_warning(self, warning: str | Exception) -&gt; None:\n        \"\"\"Add a warning to the cache.\"\"\"\n        if not isinstance(warning, (str, Exception)):\n            raise TypeError(\"warning must be either a str or Exception\")\n        self._warnings.append(warning)\n\n    def add_file(self, file: str | Path) -&gt; None:\n        \"\"\"Add a file to the cache.\"\"\"\n        if not isinstance(file, (str, Path)):\n            raise TypeError(\"file must be either a str or Exception\")\n        self._files.append(file)\n</code></pre>"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.Cache.errors","title":"<code>errors</code>  <code>property</code>","text":"<p>Get <code>errors</code> attribute.</p>"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.Cache.files","title":"<code>files</code>  <code>property</code>","text":"<p>Get <code>files</code> attribute.</p>"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.Cache.warnings","title":"<code>warnings</code>  <code>property</code>","text":"<p>Get <code>warnings</code> attribute.</p>"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.Cache.add_error","title":"<code>add_error(error)</code>","text":"<p>Add an error to the cache.</p> Source code in <code>turtle_canon/cli/utils.py</code> <pre><code>def add_error(self, error: str | Exception) -&gt; None:\n    \"\"\"Add an error to the cache.\"\"\"\n    if not isinstance(error, (str, Exception)):\n        raise TypeError(\"error must be either a str or Exception\")\n    self._errors.append(error)\n</code></pre>"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.Cache.add_file","title":"<code>add_file(file)</code>","text":"<p>Add a file to the cache.</p> Source code in <code>turtle_canon/cli/utils.py</code> <pre><code>def add_file(self, file: str | Path) -&gt; None:\n    \"\"\"Add a file to the cache.\"\"\"\n    if not isinstance(file, (str, Path)):\n        raise TypeError(\"file must be either a str or Exception\")\n    self._files.append(file)\n</code></pre>"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.Cache.add_warning","title":"<code>add_warning(warning)</code>","text":"<p>Add a warning to the cache.</p> Source code in <code>turtle_canon/cli/utils.py</code> <pre><code>def add_warning(self, warning: str | Exception) -&gt; None:\n    \"\"\"Add a warning to the cache.\"\"\"\n    if not isinstance(warning, (str, Exception)):\n        raise TypeError(\"warning must be either a str or Exception\")\n    self._warnings.append(warning)\n</code></pre>"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.print_changed_files","title":"<code>print_changed_files(files, exit_after=False)</code>","text":"<p>Print list of changed files.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>Sequence[str | Path]</code> <p>List of files with changes.</p> required <code>exit_after</code> <code>bool</code> <p>Whether or not to call <code>sys.exit(1)</code> after printing the message.</p> <code>False</code> Source code in <code>turtle_canon/cli/utils.py</code> <pre><code>def print_changed_files(files: Sequence[str | Path], exit_after: bool = False) -&gt; None:\n    \"\"\"Print list of changed files.\n\n    Parameters:\n        files: List of files with changes.\n        exit_after: Whether or not to call `sys.exit(1)` after printing the message.\n\n    \"\"\"\n    res = \"\\nChanged files:\\n\"\n    res += \"{}\\n\".join(str(_) for _ in files)\n\n    _print_message(res, target=sys.stdout, prefix=\"\", exit_after=exit_after)\n</code></pre>"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.print_error","title":"<code>print_error(message, exit_after=True)</code>","text":"<p>Print an error message to the console.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str | Exception</code> <p>The error message to print.</p> required <code>exit_after</code> <code>bool</code> <p>Whether or not to call <code>sys.exit(1)</code> after printing the message.</p> <code>True</code> Source code in <code>turtle_canon/cli/utils.py</code> <pre><code>def print_error(message: str | Exception, exit_after: bool = True) -&gt; None:\n    \"\"\"Print an error message to the console.\n\n    Parameters:\n        message: The error message to print.\n        exit_after: Whether or not to call `sys.exit(1)` after printing the message.\n\n    \"\"\"\n    res = f\"Misfire !\\n\\n{message}\"\n    if isinstance(message, Exception):\n        res += f\"\\n\\nGeneral information about the exception: {message.__doc__}\"\n    _print_message(res, target=sys.stderr, prefix=\"ERROR: \", exit_after=exit_after)\n</code></pre>"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.print_summary","title":"<code>print_summary(errors=None, warnings=None, exit_after=False)</code>","text":"<p>Print a summary, including of error and/or warning messages.</p> <p>Parameters:</p> Name Type Description Default <code>errors</code> <code>Sequence[str | Exception] | None</code> <p>List of error messages.</p> <code>None</code> <code>warnings</code> <code>Sequence[str | Exception] | None</code> <p>List of warning messages.</p> <code>None</code> <code>exit_after</code> <code>bool</code> <p>Whether or not to call <code>sys.exit(1)</code> after printing the message.</p> <code>False</code> Source code in <code>turtle_canon/cli/utils.py</code> <pre><code>def print_summary(\n    errors: Sequence[str | Exception] | None = None,\n    warnings: Sequence[str | Exception] | None = None,\n    exit_after: bool = False,\n) -&gt; None:\n    \"\"\"Print a summary, including of error and/or warning messages.\n\n    Parameters:\n        errors: List of error messages.\n        warnings: List of warning messages.\n        exit_after: Whether or not to call `sys.exit(1)` after printing the message.\n\n    \"\"\"\n    res = \"\"\n    target = sys.stdout\n\n    if errors or warnings:\n        res += \"The balls are stuck !\\n\\n\"\n        target = sys.stderr\n    else:\n        res += \"Successful Fire !\\n\"\n\n    if errors:\n        res += \"ERRORS:\\n\"\n        for error in errors:\n            res += f\"* {error}\\n\"\n            if isinstance(error, Exception):\n                res += f\"  General info: {error.__doc__}\\n\"\n\n    if warnings:\n        res += \"WARNINGS:\\n\"\n        for warning in warnings:\n            res += f\"* {warning}\\n\"\n            if isinstance(warning, Exception):\n                res += f\"  General info: {warning.__doc__}\\n\"\n\n    _print_message(res[:-1], target=target, prefix=\"\", exit_after=exit_after)\n</code></pre>"},{"location":"api_reference/cli/utils/#turtle_canon.cli.utils.print_warning","title":"<code>print_warning(message, exit_after=False)</code>","text":"<p>Print a warnings message to the console.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str | Exception</code> <p>The warning message to print.</p> required <code>exit_after</code> <code>bool</code> <p>Whether or not to call <code>sys.exit(1)</code> after printing the message.</p> <code>False</code> Source code in <code>turtle_canon/cli/utils.py</code> <pre><code>def print_warning(message: str | Exception, exit_after: bool = False) -&gt; None:\n    \"\"\"Print a warnings message to the console.\n\n    Parameters:\n        message: The warning message to print.\n        exit_after: Whether or not to call `sys.exit(1)` after printing the message.\n\n    \"\"\"\n    res = f\"Don't come too close !\\n\\n{message}\"\n    if isinstance(message, Exception):\n        res += f\"\\n\\nGeneral information about the warning: {message.__doc__}\"\n    _print_message(res, target=sys.stderr, prefix=\"WARNING: \", exit_after=exit_after)\n</code></pre>"},{"location":"api_reference/utils/exceptions/","title":"exceptions","text":"<p>Exceptions for general usage by the Turtle Canon tool.</p>"},{"location":"api_reference/utils/exceptions/#turtle_canon.utils.exceptions.FailedCreatingOntology","title":"<code>FailedCreatingOntology</code>","text":"<p>               Bases: <code>TurtleCanonException</code></p> <p>RDFlib failed to add one or more triples to a new <code>rdflib.Graph</code> object.</p> Source code in <code>turtle_canon/utils/exceptions.py</code> <pre><code>class FailedCreatingOntology(TurtleCanonException):\n    \"\"\"RDFlib failed to add one or more triples to a new `rdflib.Graph` object.\"\"\"\n</code></pre>"},{"location":"api_reference/utils/exceptions/#turtle_canon.utils.exceptions.FailedExportToFile","title":"<code>FailedExportToFile</code>","text":"<p>               Bases: <code>TurtleCanonException</code></p> <p>Failed to export an ontology to file.</p> Source code in <code>turtle_canon/utils/exceptions.py</code> <pre><code>class FailedExportToFile(TurtleCanonException):\n    \"\"\"Failed to export an ontology to file.\"\"\"\n</code></pre>"},{"location":"api_reference/utils/exceptions/#turtle_canon.utils.exceptions.FailedParsingFile","title":"<code>FailedParsingFile</code>","text":"<p>               Bases: <code>TurtleCanonException</code></p> <p>RDFlib failed parsing a Turtle file.</p> Source code in <code>turtle_canon/utils/exceptions.py</code> <pre><code>class FailedParsingFile(TurtleCanonException):\n    \"\"\"RDFlib failed parsing a Turtle file.\"\"\"\n</code></pre>"},{"location":"api_reference/utils/exceptions/#turtle_canon.utils.exceptions.FailedReadingFile","title":"<code>FailedReadingFile</code>","text":"<p>               Bases: <code>TurtleCanonException</code></p> <p>Failed to read the content of a Turtle file using UTF-8 encoding.</p> Source code in <code>turtle_canon/utils/exceptions.py</code> <pre><code>class FailedReadingFile(TurtleCanonException):\n    \"\"\"Failed to read the content of a Turtle file using UTF-8 encoding.\"\"\"\n</code></pre>"},{"location":"api_reference/utils/exceptions/#turtle_canon.utils.exceptions.InconsistencyError","title":"<code>InconsistencyError</code>","text":"<p>               Bases: <code>TurtleCanonException</code></p> <p>An inconsistency was found.</p> Source code in <code>turtle_canon/utils/exceptions.py</code> <pre><code>class InconsistencyError(TurtleCanonException):\n    \"\"\"An inconsistency was found.\"\"\"\n</code></pre>"},{"location":"api_reference/utils/exceptions/#turtle_canon.utils.exceptions.TurtleCanonException","title":"<code>TurtleCanonException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base Exception for the Turtle Canon tool.</p> Source code in <code>turtle_canon/utils/exceptions.py</code> <pre><code>class TurtleCanonException(Exception):\n    \"\"\"Base Exception for the Turtle Canon tool.\"\"\"\n</code></pre>"},{"location":"api_reference/utils/exceptions/#turtle_canon.utils.exceptions.TurtleFileNotFound","title":"<code>TurtleFileNotFound</code>","text":"<p>               Bases: <code>TurtleCanonException</code></p> <p>A Turtle file cannot be found.</p> Source code in <code>turtle_canon/utils/exceptions.py</code> <pre><code>class TurtleFileNotFound(TurtleCanonException):\n    \"\"\"A Turtle file cannot be found.\"\"\"\n</code></pre>"},{"location":"api_reference/utils/warnings/","title":"warnings","text":"<p>Warnings for general usage by the Turtle Canon tool.</p> <p>Note</p> <p>These warnings are not like regular Python <code>Warning</code>s. Instead, they are <code>Exception</code>s that will be caught and treated specially by the CLI.</p>"},{"location":"api_reference/utils/warnings/#turtle_canon.utils.warnings.EmptyFile","title":"<code>EmptyFile</code>","text":"<p>               Bases: <code>TurtleCanonWarning</code></p> <p>A file's content is empty.</p> Source code in <code>turtle_canon/utils/warnings.py</code> <pre><code>class EmptyFile(TurtleCanonWarning):\n    \"\"\"A file's content is empty.\"\"\"\n</code></pre>"},{"location":"api_reference/utils/warnings/#turtle_canon.utils.warnings.NoTriples","title":"<code>NoTriples</code>","text":"<p>               Bases: <code>TurtleCanonWarning</code></p> <p>No triples found in the parsed ontology.</p> Source code in <code>turtle_canon/utils/warnings.py</code> <pre><code>class NoTriples(TurtleCanonWarning):\n    \"\"\"No triples found in the parsed ontology.\"\"\"\n</code></pre>"},{"location":"api_reference/utils/warnings/#turtle_canon.utils.warnings.TurtleCanonWarning","title":"<code>TurtleCanonWarning</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base Warning for the Turtle Canon tool.</p> Source code in <code>turtle_canon/utils/warnings.py</code> <pre><code>class TurtleCanonWarning(Exception):\n    \"\"\"Base Warning for the Turtle Canon tool.\"\"\"\n</code></pre>"}]}